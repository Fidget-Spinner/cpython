// This file is generated by Tools/cases_generator/optimizer_generator.py
// from:
//   Python/optimizer_bytecodes.c
// Do not edit!

        case _NOP: {
            break;
        }

        case _NOP_FOR_OPTIMIZER: {
            break;
        }

        case _CHECK_PERIODIC: {
            break;
        }

        case _CHECK_PERIODIC_IF_NOT_YIELD_FROM: {
            break;
        }

        /* _QUICKEN_RESUME is not a viable micro-op for tier 2 */

        /* _LOAD_BYTECODE is not a viable micro-op for tier 2 */

        case _RESUME_CHECK: {
            break;
        }

        /* _MONITOR_RESUME is not a viable micro-op for tier 2 */

        case _LOAD_FAST_CHECK: {
            JitOptSymbol *value;
            value = GETLOCAL(oparg);
            // We guarantee this will error - just bail and don't optimize it.
            if (sym_is_null(value)) {
                ctx->done = true;
            }
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_FAST: {
            JitOptSymbol *value;
            value = GETLOCAL(oparg);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_FAST_AND_CLEAR: {
            JitOptSymbol *value;
            value = GETLOCAL(oparg);
            JitOptSymbol *temp = sym_new_null(ctx);
            GETLOCAL(oparg) = temp;
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _LOAD_CONST is not a viable micro-op for tier 2 */

        case _LOAD_CONST_MORTAL: {
            JitOptSymbol *value;
            PyObject *val = PyTuple_GET_ITEM(co->co_consts, this_instr->oparg);
            bool is_unboxable = sym_object_is_unboxable(val);
            if (is_unboxable) {
                REPLACE_OP(this_instr, _LOAD_UNBOXED, 0, (uintptr_t)_PyLong61_FromLong(val));
                value = sym_new_unboxed(ctx, NULL, val);
            }
            else {
                int opcode = _Py_IsImmortal(val) ? _LOAD_CONST_INLINE_BORROW : _LOAD_CONST_INLINE;
                REPLACE_OP(this_instr, opcode, 0, (uintptr_t)val);
                value = sym_new_const(ctx, val);
            }
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_CONST_IMMORTAL: {
            JitOptSymbol *value;
            PyObject *val = PyTuple_GET_ITEM(co->co_consts, this_instr->oparg);
            bool is_unboxable = sym_object_is_unboxable(val);
            if (is_unboxable) {
                REPLACE_OP(this_instr, _LOAD_UNBOXED, 0, (uintptr_t)_PyLong61_FromLong(val));
                value = sym_new_unboxed(ctx, NULL, val);
            }
            else {
                REPLACE_OP(this_instr, _LOAD_CONST_INLINE_BORROW, 0, (uintptr_t)val);
                value = sym_new_const(ctx, val);
            }
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_SMALL_INT: {
            JitOptSymbol *value;
            PyObject *val = PyLong_FromLong(this_instr->oparg);
            uintptr_t unboxed = _PyLong_toUnbox(this_instr->oparg);
            REPLACE_OP(this_instr, _LOAD_UNBOXED, 0, unboxed);
            value = sym_new_unboxed(ctx, NULL, val);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_FAST: {
            JitOptSymbol *value;
            value = stack_pointer[-1];
            GETLOCAL(oparg) = value;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _POP_TOP: {
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _PUSH_NULL: {
            JitOptSymbol *res;
            res = sym_new_null(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _END_FOR: {
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _END_SEND: {
            JitOptSymbol *value;
            JitOptSymbol *receiver;
            JitOptSymbol *val;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            receiver = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, value);
            sym_fail_if_boxed(ctx, receiver);
            val = sym_new_not_null(ctx);
            stack_pointer[-2] = val;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNARY_NEGATIVE: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, value);
            res = sym_new_not_null(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _UNARY_NOT: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_set_type(value, &PyBool_Type);
            res = sym_new_truthiness(ctx, value, false);
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            if (!optimize_to_bool(this_instr, ctx, value, &res)) {
                res = sym_new_truthiness(ctx, value, true);
            }
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL_BOOL: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            if (!optimize_to_bool(this_instr, ctx, value, &res)) {
                sym_set_type(value, &PyBool_Type);
                res = sym_new_truthiness(ctx, value, true);
            }
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL_INT: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            if (!optimize_to_bool(this_instr, ctx, value, &res)) {
                sym_set_type(value, &PyLong_Type);
                res = sym_new_truthiness(ctx, value, true);
            }
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL_LIST: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            if (!optimize_to_bool(this_instr, ctx, value, &res)) {
                sym_set_type(value, &PyList_Type);
                res = sym_new_type(ctx, &PyBool_Type);
            }
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL_NONE: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            if (!optimize_to_bool(this_instr, ctx, value, &res)) {
                sym_set_const(value, Py_None);
                res = sym_new_const(ctx, Py_False);
            }
            stack_pointer[-1] = res;
            break;
        }

        case _TO_BOOL_STR: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            if (!optimize_to_bool(this_instr, ctx, value, &res)) {
                res = sym_new_truthiness(ctx, value, true);
                sym_set_type(value, &PyUnicode_Type);
            }
            stack_pointer[-1] = res;
            break;
        }

        case _REPLACE_WITH_TRUE: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            res = sym_new_const(ctx, Py_True);
            stack_pointer[-1] = res;
            break;
        }

        case _UNARY_INVERT: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, value);
            res = sym_new_not_null(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _GUARD_BOTH_INT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            bool should_rerun = (sym_unbox_and_hoist_if_possible(ctx, left) ||
                             sym_unbox_and_hoist_if_possible(ctx, right));
            if (should_rerun) {
                DPRINTF(2, "Rerunning optimizer due to hoisted types.\n");
                ctx->retry = true;
                ctx->done = true;
                break;
            }
            if (sym_matches_type(left, &PyLong_Type)) {
                if (sym_matches_type(right, &PyLong_Type)) {
                    REPLACE_OP(this_instr, _NOP, 0, 0);
                }
                else {
                    REPLACE_OP(this_instr, _GUARD_TOS_INT, 0, 0);
                }
            }
            else {
                if (sym_matches_type(right, &PyLong_Type)) {
                    REPLACE_OP(this_instr, _GUARD_NOS_INT, 0, 0);
                }
            }
            sym_set_type(left, &PyLong_Type);
            sym_set_type(right, &PyLong_Type);
            break;
        }

        case _GUARD_NOS_INT: {
            JitOptSymbol *left;
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, left);
            break;
        }

        case _GUARD_TOS_INT: {
            JitOptSymbol *value;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, value);
            break;
        }

        case _BINARY_OP_MULTIPLY_INT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            if (sym_is_unboxed(left) && sym_is_unboxed(right)) {
                REPLACE_OP(this_instr, _BINARY_OP_MULTIPLY_INT_UNBOXED, 0, 0);
                res = sym_new_unboxed(ctx, &PyLong_Type, NULL);
            }
            else {
                // Uneven unboxing, bail
                if (sym_is_unboxed(left) || sym_is_unboxed(right)) {
                    ctx->contradiction = true;
                    ctx->done = true;
                }
                res = sym_new_type(ctx, &PyLong_Type);
            }
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_ADD_INT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            if (sym_is_unboxed(left) && sym_is_unboxed(right)) {
                REPLACE_OP(this_instr, _BINARY_OP_ADD_INT_UNBOXED, 0, 0);
                res = sym_new_unboxed(ctx, &PyLong_Type, NULL);
            }
            else {
                // Uneven unboxing, bail
                if (sym_is_unboxed(left) || sym_is_unboxed(right)) {
                    ctx->contradiction = true;
                    ctx->done = true;
                }
                res = sym_new_type(ctx, &PyLong_Type);
            }
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBTRACT_INT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            if (sym_is_unboxed(left) && sym_is_unboxed(right)) {
                REPLACE_OP(this_instr, _BINARY_OP_SUBTRACT_INT_UNBOXED, 0, 0);
                res = sym_new_unboxed(ctx, &PyLong_Type, NULL);
            }
            else {
                // Uneven unboxing, bail
                if (sym_is_unboxed(left) || sym_is_unboxed(right)) {
                    ctx->contradiction = true;
                    ctx->done = true;
                }
                res = sym_new_type(ctx, &PyLong_Type);
            }
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNBOX_FAST: {
            GETLOCAL(oparg) = sym_new_unboxed(ctx, &PyLong_Type, NULL);
            break;
        }

        case _BINARY_OP_MULTIPLY_INT_UNBOXED: {
            JitOptSymbol *out;
            out = sym_new_not_null(ctx);
            stack_pointer[-2] = out;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_ADD_INT_UNBOXED: {
            JitOptSymbol *out;
            out = sym_new_not_null(ctx);
            stack_pointer[-2] = out;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBTRACT_INT_UNBOXED: {
            JitOptSymbol *out;
            out = sym_new_not_null(ctx);
            stack_pointer[-2] = out;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_UNBOXED: {
            JitOptSymbol *value;
            PyObject *ptr = (PyObject *)this_instr->operand0;
            PyObject *val = PyLong_FromLong(_PyUnbox_toLong((uintptr_t)ptr));
            value = sym_new_unboxed(ctx, NULL, val);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_BOTH_FLOAT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            if (sym_matches_type(left, &PyFloat_Type)) {
                if (sym_matches_type(right, &PyFloat_Type)) {
                    REPLACE_OP(this_instr, _NOP, 0, 0);
                }
                else {
                    REPLACE_OP(this_instr, _GUARD_TOS_FLOAT, 0, 0);
                }
            }
            else {
                if (sym_matches_type(right, &PyFloat_Type)) {
                    REPLACE_OP(this_instr, _GUARD_NOS_FLOAT, 0, 0);
                }
            }
            sym_set_type(left, &PyFloat_Type);
            sym_set_type(right, &PyFloat_Type);
            break;
        }

        case _GUARD_NOS_FLOAT: {
            JitOptSymbol *left;
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, left);
            break;
        }

        case _GUARD_TOS_FLOAT: {
            JitOptSymbol *value;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, value);
            break;
        }

        case _BINARY_OP_MULTIPLY_FLOAT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            if (sym_is_const(ctx, left) && sym_is_const(ctx, right) &&
                sym_matches_type(left, &PyFloat_Type) && sym_matches_type(right, &PyFloat_Type))
            {
                assert(PyFloat_CheckExact(sym_get_const(ctx, left)));
                assert(PyFloat_CheckExact(sym_get_const(ctx, right)));
                PyObject *temp = PyFloat_FromDouble(
                    PyFloat_AS_DOUBLE(sym_get_const(ctx, left)) *
                    PyFloat_AS_DOUBLE(sym_get_const(ctx, right)));
                if (temp == NULL) {
                    goto error;
                }
                res = sym_new_const(ctx, temp);
                stack_pointer[-2] = res;
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                Py_DECREF(temp);
                // TODO gh-115506:
                // replace opcode with constant propagated one and update tests!
            }
            else {
                res = sym_new_type(ctx, &PyFloat_Type);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
            }
            stack_pointer[-1] = res;
            break;
        }

        case _BINARY_OP_ADD_FLOAT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            if (sym_is_const(ctx, left) && sym_is_const(ctx, right) &&
                sym_matches_type(left, &PyFloat_Type) && sym_matches_type(right, &PyFloat_Type))
            {
                assert(PyFloat_CheckExact(sym_get_const(ctx, left)));
                assert(PyFloat_CheckExact(sym_get_const(ctx, right)));
                PyObject *temp = PyFloat_FromDouble(
                    PyFloat_AS_DOUBLE(sym_get_const(ctx, left)) +
                    PyFloat_AS_DOUBLE(sym_get_const(ctx, right)));
                if (temp == NULL) {
                    goto error;
                }
                res = sym_new_const(ctx, temp);
                stack_pointer[-2] = res;
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                Py_DECREF(temp);
                // TODO gh-115506:
                // replace opcode with constant propagated one and update tests!
            }
            else {
                res = sym_new_type(ctx, &PyFloat_Type);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
            }
            stack_pointer[-1] = res;
            break;
        }

        case _BINARY_OP_SUBTRACT_FLOAT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            if (sym_is_const(ctx, left) && sym_is_const(ctx, right) &&
                sym_matches_type(left, &PyFloat_Type) && sym_matches_type(right, &PyFloat_Type))
            {
                assert(PyFloat_CheckExact(sym_get_const(ctx, left)));
                assert(PyFloat_CheckExact(sym_get_const(ctx, right)));
                PyObject *temp = PyFloat_FromDouble(
                    PyFloat_AS_DOUBLE(sym_get_const(ctx, left)) -
                    PyFloat_AS_DOUBLE(sym_get_const(ctx, right)));
                if (temp == NULL) {
                    goto error;
                }
                res = sym_new_const(ctx, temp);
                stack_pointer[-2] = res;
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                Py_DECREF(temp);
                // TODO gh-115506:
                // replace opcode with constant propagated one and update tests!
            }
            else {
                res = sym_new_type(ctx, &PyFloat_Type);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
            }
            stack_pointer[-1] = res;
            break;
        }

        case _GUARD_BOTH_UNICODE: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            if (sym_matches_type(left, &PyUnicode_Type) &&
                sym_matches_type(right, &PyUnicode_Type)) {
                REPLACE_OP(this_instr, _NOP, 0 ,0);
            }
            sym_set_type(left, &PyUnicode_Type);
            sym_set_type(right, &PyUnicode_Type);
            break;
        }

        case _BINARY_OP_ADD_UNICODE: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            if (sym_is_const(ctx, left) && sym_is_const(ctx, right) &&
                sym_matches_type(left, &PyUnicode_Type) && sym_matches_type(right, &PyUnicode_Type)) {
                PyObject *temp = PyUnicode_Concat(sym_get_const(ctx, left), sym_get_const(ctx, right));
                if (temp == NULL) {
                    goto error;
                }
                res = sym_new_const(ctx, temp);
                stack_pointer[-2] = res;
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                Py_DECREF(temp);
            }
            else {
                res = sym_new_type(ctx, &PyUnicode_Type);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
            }
            stack_pointer[-1] = res;
            break;
        }

        case _BINARY_OP_INPLACE_ADD_UNICODE: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            JitOptSymbol *res;
            if (sym_is_const(ctx, left) && sym_is_const(ctx, right) &&
                sym_matches_type(left, &PyUnicode_Type) && sym_matches_type(right, &PyUnicode_Type)) {
                PyObject *temp = PyUnicode_Concat(sym_get_const(ctx, left), sym_get_const(ctx, right));
                if (temp == NULL) {
                    goto error;
                }
                res = sym_new_const(ctx, temp);
                stack_pointer += -2;
                assert(WITHIN_STACK_BOUNDS());
                Py_DECREF(temp);
            }
            else {
                res = sym_new_type(ctx, &PyUnicode_Type);
                stack_pointer += -2;
                assert(WITHIN_STACK_BOUNDS());
            }
            // _STORE_FAST:
            GETLOCAL(this_instr->operand0) = res;
            break;
        }

        case _GUARD_BINARY_OP_EXTEND: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, right);
            sym_fail_if_boxed(ctx, left);
            break;
        }

        case _BINARY_OP_EXTEND: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, right);
            sym_fail_if_boxed(ctx, left);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_SLICE: {
            JitOptSymbol *stop;
            JitOptSymbol *start;
            JitOptSymbol *container;
            JitOptSymbol *res;
            stop = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            start = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            container = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            sym_fail_if_boxed(ctx, stop);
            sym_fail_if_boxed(ctx, start);
            sym_fail_if_boxed(ctx, container);
            res = sym_new_not_null(ctx);
            stack_pointer[-3] = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_SLICE: {
            JitOptSymbol *stop;
            JitOptSymbol *start;
            JitOptSymbol *container;
            JitOptSymbol *v;
            stop = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            start = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            container = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            v = sym_fail_if_boxed(ctx, stack_pointer[-4]);
            sym_fail_if_boxed(ctx, stop);
            sym_fail_if_boxed(ctx, start);
            sym_fail_if_boxed(ctx, container);
            sym_fail_if_boxed(ctx, v);
            stack_pointer += -4;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBSCR_LIST_INT: {
            JitOptSymbol *sub_st;
            JitOptSymbol *list_st;
            JitOptSymbol *res;
            sub_st = stack_pointer[-1];
            if (sym_is_unboxed(sub_st)) {
                REPLACE_OP(this_instr, _BINARY_OP_SUBSCR_LIST_INT_UNBOXED, 0, 0);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBSCR_LIST_INT_UNBOXED: {
            JitOptSymbol *res;
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBSCR_STR_INT: {
            JitOptSymbol *sub_st;
            JitOptSymbol *str_st;
            JitOptSymbol *res;
            sub_st = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            str_st = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, sub_st);
            sym_fail_if_boxed(ctx, str_st);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBSCR_TUPLE_INT: {
            JitOptSymbol *res;
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBSCR_DICT: {
            JitOptSymbol *sub_st;
            JitOptSymbol *dict_st;
            JitOptSymbol *res;
            sub_st = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            dict_st = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, sub_st);
            sym_fail_if_boxed(ctx, dict_st);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBSCR_CHECK_FUNC: {
            JitOptSymbol *container;
            JitOptSymbol *getitem;
            container = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, container);
            getitem = sym_new_not_null(ctx);
            stack_pointer[0] = getitem;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP_SUBSCR_INIT_CALL: {
            JitOptSymbol *getitem;
            JitOptSymbol *sub;
            JitOptSymbol *container;
            _Py_UOpsAbstractFrame *new_frame;
            new_frame = NULL;
            ctx->done = true;
            stack_pointer[-3] = (JitOptSymbol *)new_frame;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LIST_APPEND: {
            JitOptSymbol *v;
            JitOptSymbol *list;
            v = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            list = sym_fail_if_boxed(ctx, stack_pointer[-2 - (oparg-1)]);
            sym_fail_if_boxed(ctx, v);
            sym_fail_if_boxed(ctx, list);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _SET_ADD: {
            JitOptSymbol *v;
            JitOptSymbol *set;
            v = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            set = sym_fail_if_boxed(ctx, stack_pointer[-2 - (oparg-1)]);
            sym_fail_if_boxed(ctx, v);
            sym_fail_if_boxed(ctx, set);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_SUBSCR: {
            JitOptSymbol *sub;
            JitOptSymbol *container;
            JitOptSymbol *v;
            sub = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            container = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            v = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            sym_fail_if_boxed(ctx, sub);
            sym_fail_if_boxed(ctx, container);
            sym_fail_if_boxed(ctx, v);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_SUBSCR_LIST_INT: {
            JitOptSymbol *sub_st;
            JitOptSymbol *list_st;
            JitOptSymbol *value;
            sub_st = stack_pointer[-1];
            if (sym_is_unboxed(sub_st)) {
                REPLACE_OP(this_instr, _STORE_SUBSCR_LIST_INT_UNBOXED, 0, 0);
            }
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_SUBSCR_LIST_INT_UNBOXED: {
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_SUBSCR_DICT: {
            JitOptSymbol *sub;
            JitOptSymbol *dict_st;
            JitOptSymbol *value;
            sub = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            dict_st = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            value = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            sym_fail_if_boxed(ctx, sub);
            sym_fail_if_boxed(ctx, dict_st);
            sym_fail_if_boxed(ctx, value);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DELETE_SUBSCR: {
            JitOptSymbol *sub;
            JitOptSymbol *container;
            sub = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            container = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, sub);
            sym_fail_if_boxed(ctx, container);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_INTRINSIC_1: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, value);
            res = sym_new_not_null(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _CALL_INTRINSIC_2: {
            JitOptSymbol *value1_st;
            JitOptSymbol *value2_st;
            JitOptSymbol *res;
            value1_st = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            value2_st = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, value1_st);
            sym_fail_if_boxed(ctx, value2_st);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _RETURN_VALUE: {
            JitOptSymbol *retval;
            JitOptSymbol *res;
            retval = stack_pointer[-1];
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            ctx->frame->stack_pointer = stack_pointer;
            frame_pop(ctx);
            stack_pointer = ctx->frame->stack_pointer;
            /* Stack space handling */
            assert(corresponding_check_stack == NULL);
            assert(co != NULL);
            int framesize = co->co_framesize;
            assert(framesize > 0);
            assert(framesize <= curr_space);
            curr_space -= framesize;
            co = get_code(this_instr);
            if (co == NULL) {
                // might be impossible, but bailing is still safe
                ctx->done = true;
            }
            res = retval;
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GET_AITER: {
            JitOptSymbol *obj;
            JitOptSymbol *iter;
            obj = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, obj);
            iter = sym_new_not_null(ctx);
            stack_pointer[-1] = iter;
            break;
        }

        case _GET_ANEXT: {
            JitOptSymbol *aiter;
            JitOptSymbol *awaitable;
            aiter = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, aiter);
            awaitable = sym_new_not_null(ctx);
            stack_pointer[0] = awaitable;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GET_AWAITABLE: {
            JitOptSymbol *iterable;
            JitOptSymbol *iter;
            iterable = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iterable);
            iter = sym_new_not_null(ctx);
            stack_pointer[-1] = iter;
            break;
        }

        /* _SEND is not a viable micro-op for tier 2 */

        case _SEND_GEN_FRAME: {
            // We are about to hit the end of the trace:
            ctx->done = true;
            break;
        }

        case _YIELD_VALUE: {
            JitOptSymbol *res;
            res = sym_new_unknown(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _POP_EXCEPT: {
            JitOptSymbol *exc_value;
            exc_value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, exc_value);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_COMMON_CONSTANT: {
            JitOptSymbol *value;
            value = sym_new_not_null(ctx);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_BUILD_CLASS: {
            JitOptSymbol *bc;
            bc = sym_new_not_null(ctx);
            stack_pointer[0] = bc;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_NAME: {
            JitOptSymbol *v;
            v = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, v);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DELETE_NAME: {
            break;
        }

        case _UNPACK_SEQUENCE: {
            JitOptSymbol *seq;
            JitOptSymbol **values;
            values = &stack_pointer[-1];
            /* This has to be done manually */
            for (int i = 0; i < oparg; i++) {
                values[i] = sym_new_unknown(ctx);
            }
            stack_pointer += -1 + oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNPACK_SEQUENCE_TWO_TUPLE: {
            JitOptSymbol *seq;
            JitOptSymbol *val1;
            JitOptSymbol *val0;
            seq = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            val0 = sym_tuple_getitem(ctx, seq, 0);
            val1 = sym_tuple_getitem(ctx, seq, 1);
            stack_pointer[-1] = val1;
            stack_pointer[0] = val0;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNPACK_SEQUENCE_TUPLE: {
            JitOptSymbol *seq;
            JitOptSymbol **values;
            seq = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            values = &stack_pointer[-1];
            for (int i = 0; i < oparg; i++) {
                values[i] = sym_tuple_getitem(ctx, seq, i);
            }
            stack_pointer += -1 + oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNPACK_SEQUENCE_LIST: {
            JitOptSymbol *seq;
            JitOptSymbol **values;
            seq = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, seq);
            values = &stack_pointer[-1];
            for (int _i = oparg; --_i >= 0;) {
                values[_i] = sym_new_not_null(ctx);
            }
            stack_pointer += -1 + oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _UNPACK_EX: {
            JitOptSymbol *seq;
            JitOptSymbol **values;
            values = &stack_pointer[-1];
            /* This has to be done manually */
            int totalargs = (oparg & 0xFF) + (oparg >> 8) + 1;
            for (int i = 0; i < totalargs; i++) {
                values[i] = sym_new_unknown(ctx);
            }
            stack_pointer += (oparg & 0xFF) + (oparg >> 8);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_ATTR: {
            JitOptSymbol *owner;
            JitOptSymbol *v;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            v = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, owner);
            sym_fail_if_boxed(ctx, v);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DELETE_ATTR: {
            JitOptSymbol *owner;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, owner);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_GLOBAL: {
            JitOptSymbol *v;
            v = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, v);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DELETE_GLOBAL: {
            break;
        }

        case _LOAD_LOCALS: {
            JitOptSymbol *locals;
            locals = sym_new_not_null(ctx);
            stack_pointer[0] = locals;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _LOAD_FROM_DICT_OR_GLOBALS is not a viable micro-op for tier 2 */

        case _LOAD_NAME: {
            JitOptSymbol *v;
            v = sym_new_not_null(ctx);
            stack_pointer[0] = v;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_GLOBAL: {
            JitOptSymbol **res;
            res = &stack_pointer[0];
            res[0] = sym_new_not_null(ctx);
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _PUSH_NULL_CONDITIONAL: {
            JitOptSymbol *null = NULL;
            int opcode = (oparg & 1) ? _PUSH_NULL : _NOP;
            REPLACE_OP(this_instr, opcode, 0, 0);
            null = sym_new_null(ctx);
            if (oparg & 1) stack_pointer[0] = null;
            stack_pointer += (oparg & 1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_GLOBALS_VERSION: {
            break;
        }

        case _LOAD_GLOBAL_MODULE: {
            JitOptSymbol *res;
            res = sym_new_not_null(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_GLOBAL_BUILTINS: {
            JitOptSymbol *res;
            res = sym_new_not_null(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DELETE_FAST: {
            break;
        }

        case _MAKE_CELL: {
            break;
        }

        case _DELETE_DEREF: {
            break;
        }

        case _LOAD_FROM_DICT_OR_DEREF: {
            JitOptSymbol *class_dict_st;
            JitOptSymbol *value;
            class_dict_st = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, class_dict_st);
            value = sym_new_not_null(ctx);
            stack_pointer[-1] = value;
            break;
        }

        case _LOAD_DEREF: {
            JitOptSymbol *value;
            value = sym_new_not_null(ctx);
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_DEREF: {
            JitOptSymbol *v;
            v = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, v);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COPY_FREE_VARS: {
            break;
        }

        case _BUILD_STRING: {
            JitOptSymbol **pieces;
            JitOptSymbol *str;
            pieces = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, pieces[_i]);
            }
            str = sym_new_not_null(ctx);
            stack_pointer[-oparg] = str;
            stack_pointer += 1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BUILD_TUPLE: {
            JitOptSymbol **values;
            JitOptSymbol *tup;
            values = &stack_pointer[-oparg];
            tup = sym_new_tuple(ctx, oparg, values);
            stack_pointer[-oparg] = tup;
            stack_pointer += 1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BUILD_LIST: {
            JitOptSymbol **values;
            JitOptSymbol *list;
            values = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, values[_i]);
            }
            list = sym_new_not_null(ctx);
            stack_pointer[-oparg] = list;
            stack_pointer += 1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LIST_EXTEND: {
            JitOptSymbol *iterable_st;
            JitOptSymbol *list_st;
            iterable_st = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            list_st = sym_fail_if_boxed(ctx, stack_pointer[-2 - (oparg-1)]);
            sym_fail_if_boxed(ctx, iterable_st);
            sym_fail_if_boxed(ctx, list_st);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _SET_UPDATE: {
            JitOptSymbol *iterable;
            JitOptSymbol *set;
            iterable = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            set = sym_fail_if_boxed(ctx, stack_pointer[-2 - (oparg-1)]);
            sym_fail_if_boxed(ctx, iterable);
            sym_fail_if_boxed(ctx, set);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BUILD_SET: {
            JitOptSymbol **values;
            JitOptSymbol *set;
            values = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, values[_i]);
            }
            set = sym_new_not_null(ctx);
            stack_pointer[-oparg] = set;
            stack_pointer += 1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BUILD_MAP: {
            JitOptSymbol **values;
            JitOptSymbol *map;
            values = &stack_pointer[-oparg*2];
            for (int _i = oparg*2; --_i >= 0;) {
                sym_fail_if_boxed(ctx, values[_i]);
            }
            map = sym_new_not_null(ctx);
            stack_pointer[-oparg*2] = map;
            stack_pointer += 1 - oparg*2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _SETUP_ANNOTATIONS: {
            break;
        }

        case _DICT_UPDATE: {
            JitOptSymbol *update;
            JitOptSymbol *dict;
            update = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            dict = sym_fail_if_boxed(ctx, stack_pointer[-2 - (oparg - 1)]);
            sym_fail_if_boxed(ctx, update);
            sym_fail_if_boxed(ctx, dict);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _DICT_MERGE: {
            JitOptSymbol *update;
            JitOptSymbol *dict;
            JitOptSymbol *callable;
            update = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            dict = sym_fail_if_boxed(ctx, stack_pointer[-2 - (oparg - 1)]);
            callable = sym_fail_if_boxed(ctx, stack_pointer[-5 - (oparg - 1)]);
            sym_fail_if_boxed(ctx, update);
            sym_fail_if_boxed(ctx, dict);
            sym_fail_if_boxed(ctx, callable);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MAP_ADD: {
            JitOptSymbol *value;
            JitOptSymbol *key;
            JitOptSymbol *dict_st;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            key = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            dict_st = sym_fail_if_boxed(ctx, stack_pointer[-3 - (oparg - 1)]);
            sym_fail_if_boxed(ctx, value);
            sym_fail_if_boxed(ctx, key);
            sym_fail_if_boxed(ctx, dict_st);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_SUPER_ATTR_ATTR: {
            JitOptSymbol *self_st;
            JitOptSymbol *class_st;
            JitOptSymbol *global_super_st;
            JitOptSymbol *attr_st;
            self_st = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            class_st = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            global_super_st = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            sym_fail_if_boxed(ctx, self_st);
            sym_fail_if_boxed(ctx, class_st);
            sym_fail_if_boxed(ctx, global_super_st);
            attr_st = sym_new_not_null(ctx);
            stack_pointer[-3] = attr_st;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_SUPER_ATTR_METHOD: {
            JitOptSymbol *self_st;
            JitOptSymbol *class_st;
            JitOptSymbol *global_super_st;
            JitOptSymbol *attr;
            JitOptSymbol *self_or_null;
            self_st = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            class_st = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            global_super_st = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            sym_fail_if_boxed(ctx, self_st);
            sym_fail_if_boxed(ctx, class_st);
            sym_fail_if_boxed(ctx, global_super_st);
            attr = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            stack_pointer[-3] = attr;
            stack_pointer[-2] = self_or_null;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_ATTR: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            JitOptSymbol **self_or_null;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            self_or_null = &stack_pointer[0];
            (void)owner;
            attr = sym_new_not_null(ctx);
            if (oparg &1) {
                self_or_null[0] = sym_new_unknown(ctx);
            }
            stack_pointer[-1] = attr;
            stack_pointer += (oparg&1);
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_TYPE_VERSION: {
            JitOptSymbol *owner;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            uint32_t type_version = (uint32_t)this_instr->operand0;
            assert(type_version);
            if (sym_matches_type_version(owner, type_version)) {
                REPLACE_OP(this_instr, _NOP, 0, 0);
            } else {
                // add watcher so that whenever the type changes we invalidate this
                PyTypeObject *type = _PyType_LookupByVersion(type_version);
                // if the type is null, it was not found in the cache (there was a conflict)
                // with the key, in which case we can't trust the version
                if (type) {
                    // if the type version was set properly, then add a watcher
                    // if it wasn't this means that the type version was previously set to something else
                    // and we set the owner to bottom, so we don't need to add a watcher because we must have
                    // already added one earlier.
                    if (sym_set_type_version(owner, type_version)) {
                        PyType_Watch(TYPE_WATCHER_ID, (PyObject *)type);
                        _Py_BloomFilter_Add(dependencies, type);
                    }
                }
            }
            break;
        }

        case _GUARD_TYPE_VERSION_AND_LOCK: {
            JitOptSymbol *owner;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, owner);
            break;
        }

        case _CHECK_MANAGED_OBJECT_HAS_VALUES: {
            JitOptSymbol *owner;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, owner);
            break;
        }

        case _LOAD_ATTR_INSTANCE_VALUE: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            uint16_t offset = (uint16_t)this_instr->operand0;
            attr = sym_new_not_null(ctx);
            (void)offset;
            stack_pointer[-1] = attr;
            break;
        }

        case _LOAD_ATTR_MODULE: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            uint32_t dict_version = (uint32_t)this_instr->operand0;
            uint16_t index = (uint16_t)this_instr->operand0;
            (void)dict_version;
            (void)index;
            attr = NULL;
            if (sym_is_const(ctx, owner)) {
                PyModuleObject *mod = (PyModuleObject *)sym_get_const(ctx, owner);
                if (PyModule_CheckExact(mod)) {
                    PyObject *dict = mod->md_dict;
                    stack_pointer[-1] = attr;
                    uint64_t watched_mutations = get_mutations(dict);
                    if (watched_mutations < _Py_MAX_ALLOWED_GLOBALS_MODIFICATIONS) {
                        PyDict_Watch(GLOBALS_WATCHER_ID, dict);
                        _Py_BloomFilter_Add(dependencies, dict);
                        PyObject *res = convert_global_to_const(this_instr, dict, true);
                        attr = sym_new_const(ctx, res);
                    }
                }
            }
            if (attr == NULL) {
                /* No conversion made. We don't know what `attr` is. */
                attr = sym_new_not_null(ctx);
            }
            stack_pointer[-1] = attr;
            break;
        }

        case _LOAD_ATTR_WITH_HINT: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            uint16_t hint = (uint16_t)this_instr->operand0;
            attr = sym_new_not_null(ctx);
            (void)hint;
            stack_pointer[-1] = attr;
            break;
        }

        case _LOAD_ATTR_SLOT: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            uint16_t index = (uint16_t)this_instr->operand0;
            attr = sym_new_not_null(ctx);
            (void)index;
            stack_pointer[-1] = attr;
            break;
        }

        case _CHECK_ATTR_CLASS: {
            JitOptSymbol *owner;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, owner);
            break;
        }

        case _LOAD_ATTR_CLASS: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            PyObject *descr = (PyObject *)this_instr->operand0;
            attr = sym_new_not_null(ctx);
            (void)descr;
            stack_pointer[-1] = attr;
            break;
        }

        case _LOAD_ATTR_PROPERTY_FRAME: {
            JitOptSymbol *owner;
            _Py_UOpsAbstractFrame *new_frame;
            PyObject *fget = (PyObject *)this_instr->operand0;
            (void)fget;
            new_frame = NULL;
            ctx->done = true;
            stack_pointer[-1] = (JitOptSymbol *)new_frame;
            break;
        }

        /* _LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN is not a viable micro-op for tier 2 */

        case _GUARD_DORV_NO_DICT: {
            JitOptSymbol *owner;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, owner);
            break;
        }

        case _STORE_ATTR_INSTANCE_VALUE: {
            JitOptSymbol *owner;
            JitOptSymbol *value;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            value = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, owner);
            sym_fail_if_boxed(ctx, value);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_ATTR_WITH_HINT: {
            JitOptSymbol *owner;
            JitOptSymbol *value;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            value = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, owner);
            sym_fail_if_boxed(ctx, value);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _STORE_ATTR_SLOT: {
            JitOptSymbol *owner;
            JitOptSymbol *value;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            value = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, owner);
            sym_fail_if_boxed(ctx, value);
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COMPARE_OP: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            if (oparg & 16) {
                res = sym_new_type(ctx, &PyBool_Type);
            }
            else {
                stack_pointer += -2;
                assert(WITHIN_STACK_BOUNDS());
                res = _Py_uop_sym_new_not_null(ctx);
                stack_pointer += 2;
                assert(WITHIN_STACK_BOUNDS());
            }
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COMPARE_OP_FLOAT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            res = sym_new_type(ctx, &PyBool_Type);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COMPARE_OP_INT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            right = stack_pointer[-1];
            left = stack_pointer[-2];
            if (sym_is_unboxed(left) && sym_is_unboxed(right)) {
                REPLACE_OP(this_instr, _COMPARE_OP_INT_UNBOXED, oparg, 0);
            }
            // uneven boxing. bail.
            else if (sym_is_unboxed(left) || sym_is_unboxed(right)) {
                ctx->contradiction = true;
                ctx->done = true;
            }
            res = sym_new_type(ctx, &PyBool_Type);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COMPARE_OP_INT_UNBOXED: {
            JitOptSymbol *res;
            res = sym_new_type(ctx, &PyBool_Type);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COMPARE_OP_STR: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            res = sym_new_type(ctx, &PyBool_Type);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _IS_OP: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            res = sym_new_type(ctx, &PyBool_Type);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CONTAINS_OP: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            res = sym_new_type(ctx, &PyBool_Type);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CONTAINS_OP_SET: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *b;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, right);
            sym_fail_if_boxed(ctx, left);
            b = sym_new_not_null(ctx);
            stack_pointer[-2] = b;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CONTAINS_OP_DICT: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *b;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, right);
            sym_fail_if_boxed(ctx, left);
            b = sym_new_not_null(ctx);
            stack_pointer[-2] = b;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_EG_MATCH: {
            JitOptSymbol *match_type_st;
            JitOptSymbol *exc_value_st;
            JitOptSymbol *rest;
            JitOptSymbol *match;
            match_type_st = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            exc_value_st = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, match_type_st);
            sym_fail_if_boxed(ctx, exc_value_st);
            rest = sym_new_not_null(ctx);
            match = sym_new_not_null(ctx);
            stack_pointer[-2] = rest;
            stack_pointer[-1] = match;
            break;
        }

        case _CHECK_EXC_MATCH: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *b;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, right);
            sym_fail_if_boxed(ctx, left);
            b = sym_new_not_null(ctx);
            stack_pointer[-1] = b;
            break;
        }

        case _IMPORT_NAME: {
            JitOptSymbol *fromlist;
            JitOptSymbol *level;
            JitOptSymbol *res;
            fromlist = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            level = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, fromlist);
            sym_fail_if_boxed(ctx, level);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _IMPORT_FROM: {
            JitOptSymbol *from;
            JitOptSymbol *res;
            from = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, from);
            res = sym_new_not_null(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 */

        /* _POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 */

        case _IS_NONE: {
            JitOptSymbol *value;
            JitOptSymbol *b;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, value);
            b = sym_new_not_null(ctx);
            stack_pointer[-1] = b;
            break;
        }

        case _GET_LEN: {
            JitOptSymbol *obj;
            JitOptSymbol *len;
            obj = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, obj);
            len = sym_new_not_null(ctx);
            stack_pointer[0] = len;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MATCH_CLASS: {
            JitOptSymbol *names;
            JitOptSymbol *type;
            JitOptSymbol *subject;
            JitOptSymbol *attrs;
            names = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            type = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            subject = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            sym_fail_if_boxed(ctx, names);
            sym_fail_if_boxed(ctx, type);
            sym_fail_if_boxed(ctx, subject);
            attrs = sym_new_not_null(ctx);
            stack_pointer[-3] = attrs;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MATCH_MAPPING: {
            JitOptSymbol *subject;
            JitOptSymbol *res;
            subject = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, subject);
            res = sym_new_not_null(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MATCH_SEQUENCE: {
            JitOptSymbol *subject;
            JitOptSymbol *res;
            subject = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, subject);
            res = sym_new_not_null(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MATCH_KEYS: {
            JitOptSymbol *keys;
            JitOptSymbol *subject;
            JitOptSymbol *values_or_none;
            keys = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            subject = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, keys);
            sym_fail_if_boxed(ctx, subject);
            values_or_none = sym_new_not_null(ctx);
            stack_pointer[0] = values_or_none;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GET_ITER: {
            JitOptSymbol *iterable;
            JitOptSymbol *iter;
            iterable = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iterable);
            iter = sym_new_not_null(ctx);
            stack_pointer[-1] = iter;
            break;
        }

        case _GET_YIELD_FROM_ITER: {
            JitOptSymbol *iterable;
            JitOptSymbol *iter;
            iterable = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iterable);
            iter = sym_new_not_null(ctx);
            stack_pointer[-1] = iter;
            break;
        }

        /* _FOR_ITER is not a viable micro-op for tier 2 */

        case _FOR_ITER_TIER_TWO: {
            JitOptSymbol *iter;
            JitOptSymbol *next;
            iter = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iter);
            next = sym_new_not_null(ctx);
            stack_pointer[0] = next;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _INSTRUMENTED_FOR_ITER is not a viable micro-op for tier 2 */

        case _ITER_CHECK_LIST: {
            JitOptSymbol *iter;
            iter = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iter);
            break;
        }

        /* _ITER_JUMP_LIST is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_LIST: {
            JitOptSymbol *iter;
            iter = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iter);
            break;
        }

        case _ITER_NEXT_LIST: {
            JitOptSymbol *iter;
            JitOptSymbol *next;
            iter = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iter);
            next = sym_new_not_null(ctx);
            stack_pointer[0] = next;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _ITER_CHECK_TUPLE: {
            JitOptSymbol *iter;
            iter = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iter);
            break;
        }

        /* _ITER_JUMP_TUPLE is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_TUPLE: {
            JitOptSymbol *iter;
            iter = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iter);
            break;
        }

        case _ITER_NEXT_TUPLE: {
            JitOptSymbol *iter;
            JitOptSymbol *next;
            iter = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iter);
            next = sym_new_not_null(ctx);
            stack_pointer[0] = next;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _ITER_CHECK_RANGE: {
            JitOptSymbol *iter;
            iter = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iter);
            break;
        }

        /* _ITER_JUMP_RANGE is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_RANGE: {
            JitOptSymbol *iter;
            iter = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, iter);
            break;
        }

        case _ITER_NEXT_RANGE: {
            JitOptSymbol *iter;
            JitOptSymbol *next;
            REPLACE_OP(this_instr, _ITER_NEXT_RANGE_UNBOXED, oparg, 0);
            next = sym_new_unboxed(ctx, &PyLong_Type, NULL);
            stack_pointer[0] = next;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _ITER_NEXT_RANGE_UNBOXED: {
            JitOptSymbol *next;
            next = sym_new_unboxed(ctx, &PyLong_Type, NULL);
            stack_pointer[0] = next;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _FOR_ITER_GEN_FRAME: {
            /* We are about to hit the end of the trace */
            ctx->done = true;
            break;
        }

        case _LOAD_SPECIAL: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            JitOptSymbol *self_or_null;
            attr = sym_new_not_null(ctx);
            self_or_null = sym_new_unknown(ctx);
            stack_pointer[-1] = attr;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _WITH_EXCEPT_START: {
            JitOptSymbol *val;
            JitOptSymbol *lasti;
            JitOptSymbol *exit_self;
            JitOptSymbol *exit_func;
            JitOptSymbol *res;
            val = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            lasti = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            exit_self = sym_fail_if_boxed(ctx, stack_pointer[-4]);
            exit_func = sym_fail_if_boxed(ctx, stack_pointer[-5]);
            sym_fail_if_boxed(ctx, val);
            sym_fail_if_boxed(ctx, lasti);
            sym_fail_if_boxed(ctx, exit_self);
            sym_fail_if_boxed(ctx, exit_func);
            res = sym_new_not_null(ctx);
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _PUSH_EXC_INFO: {
            JitOptSymbol *exc;
            JitOptSymbol *prev_exc;
            JitOptSymbol *new_exc;
            exc = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, exc);
            prev_exc = sym_new_not_null(ctx);
            new_exc = sym_new_not_null(ctx);
            stack_pointer[-1] = prev_exc;
            stack_pointer[0] = new_exc;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT: {
            JitOptSymbol *owner;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, owner);
            break;
        }

        case _GUARD_KEYS_VERSION: {
            JitOptSymbol *owner;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, owner);
            break;
        }

        case _LOAD_ATTR_METHOD_WITH_VALUES: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            JitOptSymbol *self;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            PyObject *descr = (PyObject *)this_instr->operand0;
            (void)descr;
            attr = sym_new_not_null(ctx);
            self = owner;
            stack_pointer[-1] = attr;
            stack_pointer[0] = self;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_ATTR_METHOD_NO_DICT: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            JitOptSymbol *self;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            PyObject *descr = (PyObject *)this_instr->operand0;
            (void)descr;
            attr = sym_new_not_null(ctx);
            self = owner;
            stack_pointer[-1] = attr;
            stack_pointer[0] = self;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_WITH_VALUES: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, owner);
            attr = sym_new_not_null(ctx);
            stack_pointer[-1] = attr;
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_NO_DICT: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, owner);
            attr = sym_new_not_null(ctx);
            stack_pointer[-1] = attr;
            break;
        }

        case _CHECK_ATTR_METHOD_LAZY_DICT: {
            JitOptSymbol *owner;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, owner);
            break;
        }

        case _LOAD_ATTR_METHOD_LAZY_DICT: {
            JitOptSymbol *owner;
            JitOptSymbol *attr;
            JitOptSymbol *self;
            owner = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            PyObject *descr = (PyObject *)this_instr->operand0;
            (void)descr;
            attr = sym_new_not_null(ctx);
            self = owner;
            stack_pointer[-1] = attr;
            stack_pointer[0] = self;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MAYBE_EXPAND_METHOD: {
            JitOptSymbol **args;
            JitOptSymbol *self_or_null;
            JitOptSymbol *callable;
            JitOptSymbol *func;
            JitOptSymbol *maybe_self;
            args = &stack_pointer[-oparg];
            args = &stack_pointer[-oparg];
            (void)args;
            func = sym_new_not_null(ctx);
            maybe_self = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = func;
            stack_pointer[-1 - oparg] = maybe_self;
            break;
        }

        /* _DO_CALL is not a viable micro-op for tier 2 */

        /* _MONITOR_CALL is not a viable micro-op for tier 2 */

        case _PY_FRAME_GENERAL: {
            JitOptSymbol **args;
            JitOptSymbol *self_or_null;
            JitOptSymbol *callable;
            _Py_UOpsAbstractFrame *new_frame;
            PyCodeObject *co = NULL;
            assert((this_instr + 2)->opcode == _PUSH_FRAME);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            co = get_code_with_logging((this_instr + 2));
            if (co == NULL) {
                ctx->done = true;
                break;
            }
            new_frame = frame_new(ctx, co, 0, NULL, 0);
            stack_pointer[0] = (JitOptSymbol *)new_frame;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_FUNCTION_VERSION: {
            JitOptSymbol *self_or_null;
            JitOptSymbol *callable;
            callable = sym_fail_if_boxed(ctx, stack_pointer[-2 - oparg]);
            uint32_t func_version = (uint32_t)this_instr->operand0;
            if (sym_is_const(ctx, callable) && sym_matches_type(callable, &PyFunction_Type)) {
                assert(PyFunction_Check(sym_get_const(ctx, callable)));
                REPLACE_OP(this_instr, _CHECK_FUNCTION_VERSION_INLINE, 0, func_version);
                this_instr->operand1 = (uintptr_t)sym_get_const(ctx, callable);
            }
            sym_set_type(callable, &PyFunction_Type);
            break;
        }

        case _CHECK_FUNCTION_VERSION_INLINE: {
            break;
        }

        case _CHECK_METHOD_VERSION: {
            JitOptSymbol **null;
            JitOptSymbol **callable;
            null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            break;
        }

        case _EXPAND_METHOD: {
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            break;
        }

        case _CHECK_IS_NOT_PY_CALLABLE: {
            JitOptSymbol **callable;
            callable = &stack_pointer[-2 - oparg];
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            break;
        }

        case _CALL_NON_PY_GENERAL: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_CALL_BOUND_METHOD_EXACT_ARGS: {
            JitOptSymbol *null;
            JitOptSymbol *callable;
            null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            sym_set_null(null);
            sym_set_type(callable, &PyMethod_Type);
            break;
        }

        case _INIT_CALL_BOUND_METHOD_EXACT_ARGS: {
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            callable[0] = sym_new_not_null(ctx);
            self_or_null[0] = sym_new_not_null(ctx);
            break;
        }

        case _CHECK_PEP_523: {
            /* Setting the eval frame function invalidates
             * all executors, so no need to check dynamically */
            if (_PyInterpreterState_GET()->eval_frame == NULL) {
                REPLACE_OP(this_instr, _NOP, 0 ,0);
            }
            break;
        }

        case _CHECK_FUNCTION_EXACT_ARGS: {
            JitOptSymbol *self_or_null;
            JitOptSymbol *callable;
            self_or_null = stack_pointer[-1 - oparg];
            callable = stack_pointer[-2 - oparg];
            assert(sym_matches_type(callable, &PyFunction_Type));
            if (sym_is_const(ctx, callable)) {
                if (sym_is_null(self_or_null) || sym_is_not_null(self_or_null)) {
                    PyFunctionObject *func = (PyFunctionObject *)sym_get_const(ctx, callable);
                    PyCodeObject *co = (PyCodeObject *)func->func_code;
                    if (co->co_argcount == oparg + !sym_is_null(self_or_null)) {
                        REPLACE_OP(this_instr, _NOP, 0 ,0);
                    }
                }
            }
            break;
        }

        case _CHECK_STACK_SPACE: {
            assert(corresponding_check_stack == NULL);
            corresponding_check_stack = this_instr;
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS: {
            JitOptSymbol **args;
            JitOptSymbol *self_or_null;
            JitOptSymbol *callable;
            _Py_UOpsAbstractFrame *new_frame;
            args = &stack_pointer[-oparg];
            self_or_null = stack_pointer[-1 - oparg];
            int argcount = oparg;
            PyCodeObject *co = NULL;
            assert((this_instr + 2)->opcode == _PUSH_FRAME);
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            co = get_code_with_logging((this_instr + 2));
            if (co == NULL) {
                ctx->done = true;
                break;
            }
            assert(self_or_null != NULL);
            assert(args != NULL);
            if (sym_is_not_null(self_or_null)) {
                // Bound method fiddling, same as _INIT_CALL_PY_EXACT_ARGS in VM
                args--;
                argcount++;
            }
            if (sym_is_null(self_or_null) || sym_is_not_null(self_or_null)) {
                new_frame = frame_new(ctx, co, 0, args, argcount);
            } else {
                new_frame = frame_new(ctx, co, 0, NULL, 0);
            }
            stack_pointer[0] = (JitOptSymbol *)new_frame;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _PUSH_FRAME: {
            _Py_UOpsAbstractFrame *new_frame;
            new_frame = (_Py_UOpsAbstractFrame *)stack_pointer[-1];
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            ctx->frame->stack_pointer = stack_pointer;
            ctx->frame = new_frame;
            ctx->curr_frame_depth++;
            stack_pointer = new_frame->stack_pointer;
            co = get_code(this_instr);
            if (co == NULL) {
                // should be about to _EXIT_TRACE anyway
                ctx->done = true;
                break;
            }
            frame->frame_starting_inst = &trace[i+1];
            /* Stack space handling */
            int framesize = co->co_framesize;
            assert(framesize > 0);
            curr_space += framesize;
            if (curr_space < 0 || curr_space > INT32_MAX) {
                // won't fit in signed 32-bit int
                ctx->done = true;
                break;
            }
            max_space = curr_space > max_space ? curr_space : max_space;
            if (first_valid_check_stack == NULL) {
                first_valid_check_stack = corresponding_check_stack;
            }
            else {
                if (corresponding_check_stack) {
                    // delete all but the first valid _CHECK_STACK_SPACE
                    corresponding_check_stack->opcode = _NOP;
                }
            }
            corresponding_check_stack = NULL;
            break;
        }

        case _CALL_TYPE_1: {
            JitOptSymbol *arg;
            JitOptSymbol *null;
            JitOptSymbol *callable;
            JitOptSymbol *res;
            arg = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            null = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            callable = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            sym_fail_if_boxed(ctx, arg);
            sym_fail_if_boxed(ctx, null);
            sym_fail_if_boxed(ctx, callable);
            res = sym_new_not_null(ctx);
            stack_pointer[-3] = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_STR_1: {
            JitOptSymbol *arg;
            JitOptSymbol *null;
            JitOptSymbol *callable;
            JitOptSymbol *res;
            arg = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            null = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            callable = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            sym_fail_if_boxed(ctx, arg);
            sym_fail_if_boxed(ctx, null);
            sym_fail_if_boxed(ctx, callable);
            res = sym_new_not_null(ctx);
            stack_pointer[-3] = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_TUPLE_1: {
            JitOptSymbol *arg;
            JitOptSymbol *null;
            JitOptSymbol *callable;
            JitOptSymbol *res;
            arg = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            null = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            callable = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            sym_fail_if_boxed(ctx, arg);
            sym_fail_if_boxed(ctx, null);
            sym_fail_if_boxed(ctx, callable);
            res = sym_new_not_null(ctx);
            stack_pointer[-3] = res;
            stack_pointer += -2;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_AND_ALLOCATE_OBJECT: {
            JitOptSymbol **args;
            JitOptSymbol *null;
            JitOptSymbol *callable;
            JitOptSymbol *self;
            JitOptSymbol *init;
            args = &stack_pointer[-oparg];
            args = &stack_pointer[-oparg];
            uint32_t type_version = (uint32_t)this_instr->operand0;
            (void)type_version;
            (void)args;
            self = sym_new_not_null(ctx);
            init = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = self;
            stack_pointer[-1 - oparg] = init;
            break;
        }

        case _CREATE_INIT_FRAME: {
            JitOptSymbol **args;
            JitOptSymbol *init;
            JitOptSymbol *self;
            _Py_UOpsAbstractFrame *init_frame;
            init_frame = NULL;
            ctx->done = true;
            stack_pointer[-2 - oparg] = (JitOptSymbol *)init_frame;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _EXIT_INIT_CHECK: {
            JitOptSymbol *should_be_none;
            should_be_none = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, should_be_none);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_BUILTIN_CLASS: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_BUILTIN_O: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_BUILTIN_FAST: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_BUILTIN_FAST_WITH_KEYWORDS: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_LEN: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_ISINSTANCE: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_LIST_APPEND: {
            JitOptSymbol *arg;
            JitOptSymbol *self;
            JitOptSymbol *callable;
            arg = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            self = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            callable = sym_fail_if_boxed(ctx, stack_pointer[-3]);
            sym_fail_if_boxed(ctx, arg);
            sym_fail_if_boxed(ctx, self);
            sym_fail_if_boxed(ctx, callable);
            stack_pointer += -3;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_O: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_NOARGS: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST: {
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            args = &stack_pointer[-oparg];
            self_or_null = &stack_pointer[-1 - oparg];
            callable = &stack_pointer[-2 - oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-2 - oparg] = res;
            stack_pointer += -1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        /* _MONITOR_CALL_KW is not a viable micro-op for tier 2 */

        case _MAYBE_EXPAND_METHOD_KW: {
            JitOptSymbol *kwnames_in;
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol **func;
            JitOptSymbol **maybe_self;
            JitOptSymbol *kwnames_out;
            kwnames_in = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            args = &stack_pointer[-1 - oparg];
            self_or_null = &stack_pointer[-2 - oparg];
            callable = &stack_pointer[-3 - oparg];
            sym_fail_if_boxed(ctx, kwnames_in);
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            func = &stack_pointer[-3 - oparg];
            maybe_self = &stack_pointer[-2 - oparg];
            args = &stack_pointer[-1 - oparg];
            func[0] = sym_new_not_null(ctx);
            maybe_self[0] = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            kwnames_out = sym_new_not_null(ctx);
            stack_pointer[-1] = kwnames_out;
            break;
        }

        /* _DO_CALL_KW is not a viable micro-op for tier 2 */

        case _PY_FRAME_KW: {
            JitOptSymbol *kwnames;
            JitOptSymbol **args;
            JitOptSymbol *self_or_null;
            JitOptSymbol *callable;
            _Py_UOpsAbstractFrame *new_frame;
            new_frame = NULL;
            ctx->done = true;
            stack_pointer[-3 - oparg] = (JitOptSymbol *)new_frame;
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CHECK_FUNCTION_VERSION_KW: {
            JitOptSymbol *kwnames;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            kwnames = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            self_or_null = &stack_pointer[-2 - oparg];
            callable = &stack_pointer[-3 - oparg];
            sym_fail_if_boxed(ctx, kwnames);
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            break;
        }

        case _CHECK_METHOD_VERSION_KW: {
            JitOptSymbol *kwnames;
            JitOptSymbol **null;
            JitOptSymbol **callable;
            kwnames = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            null = &stack_pointer[-2 - oparg];
            callable = &stack_pointer[-3 - oparg];
            sym_fail_if_boxed(ctx, kwnames);
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            break;
        }

        case _EXPAND_METHOD_KW: {
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            self_or_null = &stack_pointer[-2 - oparg];
            callable = &stack_pointer[-3 - oparg];
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            break;
        }

        case _CHECK_IS_NOT_PY_CALLABLE_KW: {
            JitOptSymbol *kwnames;
            JitOptSymbol **callable;
            kwnames = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            callable = &stack_pointer[-3 - oparg];
            sym_fail_if_boxed(ctx, kwnames);
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            break;
        }

        case _CALL_KW_NON_PY: {
            JitOptSymbol *kwnames;
            JitOptSymbol **args;
            JitOptSymbol **self_or_null;
            JitOptSymbol **callable;
            JitOptSymbol *res;
            kwnames = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            args = &stack_pointer[-1 - oparg];
            self_or_null = &stack_pointer[-2 - oparg];
            callable = &stack_pointer[-3 - oparg];
            sym_fail_if_boxed(ctx, kwnames);
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, self_or_null[_i]);
            }
            for (int _i = 1; --_i >= 0;) {
                sym_fail_if_boxed(ctx, callable[_i]);
            }
            res = sym_new_not_null(ctx);
            stack_pointer[-3 - oparg] = res;
            stack_pointer += -2 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _MAKE_CALLARGS_A_TUPLE: {
            JitOptSymbol *kwargs_in;
            JitOptSymbol *callargs;
            JitOptSymbol *func;
            JitOptSymbol *tuple;
            JitOptSymbol *kwargs_out;
            kwargs_in = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            callargs = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            func = sym_fail_if_boxed(ctx, stack_pointer[-4]);
            sym_fail_if_boxed(ctx, kwargs_in);
            sym_fail_if_boxed(ctx, callargs);
            sym_fail_if_boxed(ctx, func);
            tuple = sym_new_not_null(ctx);
            kwargs_out = sym_new_not_null(ctx);
            stack_pointer[-2] = tuple;
            stack_pointer[-1] = kwargs_out;
            break;
        }

        /* _DO_CALL_FUNCTION_EX is not a viable micro-op for tier 2 */

        case _MAKE_FUNCTION: {
            JitOptSymbol *codeobj_st;
            JitOptSymbol *func;
            codeobj_st = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, codeobj_st);
            func = sym_new_not_null(ctx);
            stack_pointer[-1] = func;
            break;
        }

        case _SET_FUNCTION_ATTRIBUTE: {
            JitOptSymbol *func_in;
            JitOptSymbol *attr_st;
            JitOptSymbol *func_out;
            func_in = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            attr_st = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, func_in);
            sym_fail_if_boxed(ctx, attr_st);
            func_out = sym_new_not_null(ctx);
            stack_pointer[-2] = func_out;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _RETURN_GENERATOR: {
            JitOptSymbol *res;
            ctx->frame->stack_pointer = stack_pointer;
            frame_pop(ctx);
            stack_pointer = ctx->frame->stack_pointer;
            res = sym_new_unknown(ctx);
            /* Stack space handling */
            assert(corresponding_check_stack == NULL);
            assert(co != NULL);
            int framesize = co->co_framesize;
            assert(framesize > 0);
            assert(framesize <= curr_space);
            curr_space -= framesize;
            stack_pointer[0] = res;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            co = get_code(this_instr);
            if (co == NULL) {
                // might be impossible, but bailing is still safe
                ctx->done = true;
            }
            break;
        }

        case _BUILD_SLICE: {
            JitOptSymbol **args;
            JitOptSymbol *slice;
            args = &stack_pointer[-oparg];
            for (int _i = oparg; --_i >= 0;) {
                sym_fail_if_boxed(ctx, args[_i]);
            }
            slice = sym_new_not_null(ctx);
            stack_pointer[-oparg] = slice;
            stack_pointer += 1 - oparg;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _CONVERT_VALUE: {
            JitOptSymbol *value;
            JitOptSymbol *result;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, value);
            result = sym_new_not_null(ctx);
            stack_pointer[-1] = result;
            break;
        }

        case _FORMAT_SIMPLE: {
            JitOptSymbol *value;
            JitOptSymbol *res;
            value = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            sym_fail_if_boxed(ctx, value);
            res = sym_new_not_null(ctx);
            stack_pointer[-1] = res;
            break;
        }

        case _FORMAT_WITH_SPEC: {
            JitOptSymbol *fmt_spec;
            JitOptSymbol *value;
            JitOptSymbol *res;
            fmt_spec = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            value = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            sym_fail_if_boxed(ctx, fmt_spec);
            sym_fail_if_boxed(ctx, value);
            res = sym_new_not_null(ctx);
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _COPY: {
            JitOptSymbol *bottom;
            JitOptSymbol *top;
            bottom = stack_pointer[-1 - (oparg-1)];
            assert(oparg > 0);
            top = bottom;
            stack_pointer[0] = top;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _BINARY_OP: {
            JitOptSymbol *right;
            JitOptSymbol *left;
            JitOptSymbol *res;
            right = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            left = sym_fail_if_boxed(ctx, stack_pointer[-2]);
            bool lhs_int = sym_matches_type(left, &PyLong_Type);
            bool rhs_int = sym_matches_type(right, &PyLong_Type);
            bool lhs_float = sym_matches_type(left, &PyFloat_Type);
            bool rhs_float = sym_matches_type(right, &PyFloat_Type);
            if (!((lhs_int || lhs_float) && (rhs_int || rhs_float))) {
                // There's something other than an int or float involved:
                res = sym_new_unknown(ctx);
            }
            else {
                if (oparg == NB_POWER || oparg == NB_INPLACE_POWER) {
                    // This one's fun... the *type* of the result depends on the
                    // *values* being exponentiated. However, exponents with one
                    // constant part are reasonably common, so it's probably worth
                    // trying to infer some simple cases:
                    // - A: 1 ** 1 -> 1 (int ** int -> int)
                    // - B: 1 ** -1 -> 1.0 (int ** int -> float)
                    // - C: 1.0 ** 1 -> 1.0 (float ** int -> float)
                    // - D: 1 ** 1.0 -> 1.0 (int ** float -> float)
                    // - E: -1 ** 0.5 ~> 1j (int ** float -> complex)
                    // - F: 1.0 ** 1.0 -> 1.0 (float ** float -> float)
                    // - G: -1.0 ** 0.5 ~> 1j (float ** float -> complex)
                    if (rhs_float) {
                        // Case D, E, F, or G... can't know without the sign of the LHS
                        // or whether the RHS is whole, which isn't worth the effort:
                        res = sym_new_unknown(ctx);
                    }
                    else {
                        if (lhs_float) {
                            // Case C:
                            res = sym_new_type(ctx, &PyFloat_Type);
                        }
                        else {
                            if (!sym_is_const(ctx, right)) {
                                // Case A or B... can't know without the sign of the RHS:
                                res = sym_new_unknown(ctx);
                            }
                            else {
                                if (_PyLong_IsNegative((PyLongObject *)sym_get_const(ctx, right))) {
                                    // Case B:
                                    res = sym_new_type(ctx, &PyFloat_Type);
                                }
                                else {
                                    // Case A:
                                    res = sym_new_type(ctx, &PyLong_Type);
                                }
                            }
                        }
                    }
                }
                else {
                    if (oparg == NB_TRUE_DIVIDE || oparg == NB_INPLACE_TRUE_DIVIDE) {
                        res = sym_new_type(ctx, &PyFloat_Type);
                    }
                    else {
                        if (lhs_int && rhs_int) {
                            res = sym_new_type(ctx, &PyLong_Type);
                        }
                        else {
                            res = sym_new_type(ctx, &PyFloat_Type);
                        }
                    }
                }
            }
            stack_pointer[-2] = res;
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _SWAP: {
            JitOptSymbol **top;
            JitOptSymbol **bottom;
            top = &stack_pointer[-1];
            bottom = &stack_pointer[-2 - (oparg-2)];
            JitOptSymbol *temp = bottom[0];
            bottom[0] = top[0];
            top[0] = temp;
            assert(oparg >= 2);
            break;
        }

        /* _INSTRUMENTED_LINE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_INSTRUCTION is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_JUMP_FORWARD is not a viable micro-op for tier 2 */

        /* _MONITOR_JUMP_BACKWARD is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_NOT_TAKEN is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_NONE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_NOT_NONE is not a viable micro-op for tier 2 */

        case _GUARD_IS_TRUE_POP: {
            JitOptSymbol *flag;
            flag = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            if (sym_is_const(ctx, flag)) {
                PyObject *value = sym_get_const(ctx, flag);
                assert(value != NULL);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                eliminate_pop_guard(this_instr, value != Py_True);
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
            }
            sym_set_const(flag, Py_True);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_IS_FALSE_POP: {
            JitOptSymbol *flag;
            flag = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            if (sym_is_const(ctx, flag)) {
                PyObject *value = sym_get_const(ctx, flag);
                assert(value != NULL);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                eliminate_pop_guard(this_instr, value != Py_False);
                stack_pointer += 1;
                assert(WITHIN_STACK_BOUNDS());
            }
            sym_set_const(flag, Py_False);
            stack_pointer += -1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _GUARD_IS_NONE_POP: {
            JitOptSymbol *flag;
            flag = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            if (sym_is_const(ctx, flag)) {
                PyObject *value = sym_get_const(ctx, flag);
                assert(value != NULL);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                eliminate_pop_guard(this_instr, !Py_IsNone(value));
            }
            else {
                if (sym_has_type(flag)) {
                    assert(!sym_matches_type(flag, &_PyNone_Type));
                    stack_pointer += -1;
                    assert(WITHIN_STACK_BOUNDS());
                    eliminate_pop_guard(this_instr, true);
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                }
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
            }
            sym_set_const(flag, Py_None);
            break;
        }

        case _GUARD_IS_NOT_NONE_POP: {
            JitOptSymbol *flag;
            flag = sym_fail_if_boxed(ctx, stack_pointer[-1]);
            if (sym_is_const(ctx, flag)) {
                PyObject *value = sym_get_const(ctx, flag);
                assert(value != NULL);
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
                eliminate_pop_guard(this_instr, Py_IsNone(value));
            }
            else {
                if (sym_has_type(flag)) {
                    assert(!sym_matches_type(flag, &_PyNone_Type));
                    stack_pointer += -1;
                    assert(WITHIN_STACK_BOUNDS());
                    eliminate_pop_guard(this_instr, false);
                    stack_pointer += 1;
                    assert(WITHIN_STACK_BOUNDS());
                }
                stack_pointer += -1;
                assert(WITHIN_STACK_BOUNDS());
            }
            break;
        }

        case _JUMP_TO_TOP: {
            ctx->done = true;
            break;
        }

        case _SET_IP: {
            break;
        }

        case _CHECK_STACK_SPACE_OPERAND: {
            uint32_t framesize = (uint32_t)this_instr->operand0;
            (void)framesize;
            /* We should never see _CHECK_STACK_SPACE_OPERANDs.
             * They are only created at the end of this pass. */
            Py_UNREACHABLE();
            break;
        }

        case _SAVE_RETURN_OFFSET: {
            break;
        }

        case _EXIT_TRACE: {
            PyObject *exit_p = (PyObject *)this_instr->operand0;
            (void)exit_p;
            ctx->done = true;
            break;
        }

        case _CHECK_VALIDITY: {
            break;
        }

        case _LOAD_CONST_INLINE: {
            JitOptSymbol *value;
            PyObject *ptr = (PyObject *)this_instr->operand0;
            PyObject *val = ptr;
            bool is_unboxable = sym_object_is_unboxable(val);
            if (is_unboxable) {
                REPLACE_OP(this_instr, _LOAD_UNBOXED, 0, (uintptr_t)_PyLong61_FromLong(val));
                value = sym_new_unboxed(ctx, NULL, val);
            }
            else {
                value = sym_new_const(ctx, ptr);
            }
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _POP_TOP_LOAD_CONST_INLINE: {
            JitOptSymbol *pop;
            JitOptSymbol *value;
            PyObject *ptr = (PyObject *)this_instr->operand0;
            value = sym_new_const(ctx, ptr);
            stack_pointer[-1] = value;
            break;
        }

        case _LOAD_CONST_INLINE_BORROW: {
            JitOptSymbol *value;
            PyObject *ptr = (PyObject *)this_instr->operand0;
            PyObject *val = ptr;
            bool is_unboxable = sym_object_is_unboxable(val);
            if (is_unboxable) {
                REPLACE_OP(this_instr, _LOAD_UNBOXED, 0, (uintptr_t)_PyLong61_FromLong(val));
                value = sym_new_unboxed(ctx, NULL, val);
            }
            else {
                value = sym_new_const(ctx, ptr);
            }
            stack_pointer[0] = value;
            stack_pointer += 1;
            assert(WITHIN_STACK_BOUNDS());
            break;
        }

        case _POP_TOP_LOAD_CONST_INLINE_BORROW: {
            JitOptSymbol *pop;
            JitOptSymbol *value;
            PyObject *ptr = (PyObject *)this_instr->operand0;
            value = sym_new_const(ctx, ptr);
            stack_pointer[-1] = value;
            break;
        }

        case _CHECK_FUNCTION: {
            break;
        }

        case _START_EXECUTOR: {
            break;
        }

        case _MAKE_WARM: {
            break;
        }

        case _FATAL_ERROR: {
            break;
        }

        case _CHECK_VALIDITY_AND_SET_IP: {
            break;
        }

        case _DEOPT: {
            break;
        }

        case _ERROR_POP_N: {
            break;
        }

        case _TIER2_RESUME_CHECK: {
            break;
        }

