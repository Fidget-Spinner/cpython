// This file is generated by Tools/cases_generator/generate_cases.py
// from:
//   Python/bytecodes.c
// Do not edit!

        case NOP: {
            break;
        }

        case RESUME: {
            break;
        }

        case RESUME_CHECK: {
            break;
        }

        case INSTRUMENTED_RESUME: {
            break;
        }

        case LOAD_FAST_LOAD_FAST: {
            STACK_GROW(2);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case STORE_FAST_LOAD_FAST: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case STORE_FAST_STORE_FAST: {
            STACK_SHRINK(2);
            break;
        }

        case INSTRUMENTED_END_FOR: {
            STACK_SHRINK(2);
            break;
        }

        case INSTRUMENTED_END_SEND: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case UNARY_NEGATIVE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case UNARY_NOT: {
            _Py_UOpsSymbolicExpression *___value;
            ___value = stack_pointer[-1];
            _Py_UOpsSymbolicExpression *__sym_temp = NULL;
            if (is_const(___value)) {
                PyObject *value = get_const(___value);
                PyObject *res;
                assert(PyBool_Check(value));
                res = Py_IsFalse(value) ? Py_True : Py_False;
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, (PyObject *)res, 1 , ___value);
            }
            else {
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, NULL, 1 , ___value);
            }
            if (__sym_temp == NULL) goto error;
            PEEK(-(-1)) = __sym_temp;
            break;
        }

        case _SPECIALIZE_TO_BOOL: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _TO_BOOL: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case TO_BOOL_BOOL: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case TO_BOOL_INT: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case TO_BOOL_LIST: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case TO_BOOL_NONE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case TO_BOOL_STR: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case TO_BOOL_ALWAYS_TRUE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case UNARY_INVERT: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _GUARD_BOTH_INT: {
            _Py_UOpsSymbolicExpression *___left;
            _Py_UOpsSymbolicExpression *___right;
            ___right = stack_pointer[-1];
            ___left = stack_pointer[-2];
            if (is_const(___left) && is_const(___right)) {
                PyObject *left = get_const(___left);
                PyObject *right = get_const(___right);
                DEOPT_IF(!PyLong_CheckExact(left), _GUARD_BOTH_INT);
                DEOPT_IF(!PyLong_CheckExact(right), _GUARD_BOTH_INT);
                DPRINTF(2, "const eliminated guard\n");
                break;
            }
            _Py_UOpsSymbolicExpression *right = (_Py_UOpsSymbolicExpression *)stack_pointer[-1];
            _Py_UOpsSymbolicExpression *left = (_Py_UOpsSymbolicExpression *)stack_pointer[-2];
            if (should_type_propagate) {
                sym_set_type((_Py_UOpsSymbolicExpression *)left, PYINT_TYPE, (uint32_t)0);;
                sym_set_type((_Py_UOpsSymbolicExpression *)right, PYINT_TYPE, (uint32_t)0);;
            }
            else {
                if (sym_matches_type((_Py_UOpsSymbolicExpression *)left, PYINT_TYPE, (uint32_t)0) && sym_matches_type((_Py_UOpsSymbolicExpression *)right, PYINT_TYPE, (uint32_t)0)) {
                    DPRINTF(2, "type propagation eliminated guard\n");
                    break;
                }
                goto guard_required;
            }
            break;
        }

        case _BINARY_OP_MULTIPLY_INT: {
            _Py_UOpsSymbolicExpression *___left;
            _Py_UOpsSymbolicExpression *___right;
            ___right = stack_pointer[-1];
            ___left = stack_pointer[-2];
            STACK_SHRINK(1);
            _Py_UOpsSymbolicExpression *__sym_temp = NULL;
            if (is_const(___left) && is_const(___right)) {
                PyObject *left = get_const(___left);
                PyObject *right = get_const(___right);
                PyObject *res;
                STAT_INC(BINARY_OP, hit);
                res = _PyLong_Multiply((PyLongObject *)left, (PyLongObject *)right);
                _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
                _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
                if (res == NULL) goto pop_2_error_tier_two;
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, (PyObject *)res, 2 , ___left, ___right);
            }
            else {
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, NULL, 2 , ___left, ___right);
            }
            if (__sym_temp == NULL) goto error;
            sym_set_type(__sym_temp, PYINT_TYPE, (uint32_t)0);
            PEEK(-(-1)) = __sym_temp;
            break;
        }

        case _BINARY_OP_ADD_INT: {
            _Py_UOpsSymbolicExpression *___left;
            _Py_UOpsSymbolicExpression *___right;
            ___right = stack_pointer[-1];
            ___left = stack_pointer[-2];
            STACK_SHRINK(1);
            _Py_UOpsSymbolicExpression *__sym_temp = NULL;
            if (is_const(___left) && is_const(___right)) {
                PyObject *left = get_const(___left);
                PyObject *right = get_const(___right);
                PyObject *res;
                STAT_INC(BINARY_OP, hit);
                res = _PyLong_Add((PyLongObject *)left, (PyLongObject *)right);
                _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
                _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
                if (res == NULL) goto pop_2_error_tier_two;
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, (PyObject *)res, 2 , ___left, ___right);
            }
            else {
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, NULL, 2 , ___left, ___right);
            }
            if (__sym_temp == NULL) goto error;
            sym_set_type(__sym_temp, PYINT_TYPE, (uint32_t)0);
            PEEK(-(-1)) = __sym_temp;
            break;
        }

        case _BINARY_OP_SUBTRACT_INT: {
            _Py_UOpsSymbolicExpression *___left;
            _Py_UOpsSymbolicExpression *___right;
            ___right = stack_pointer[-1];
            ___left = stack_pointer[-2];
            STACK_SHRINK(1);
            _Py_UOpsSymbolicExpression *__sym_temp = NULL;
            if (is_const(___left) && is_const(___right)) {
                PyObject *left = get_const(___left);
                PyObject *right = get_const(___right);
                PyObject *res;
                STAT_INC(BINARY_OP, hit);
                res = _PyLong_Subtract((PyLongObject *)left, (PyLongObject *)right);
                _Py_DECREF_SPECIALIZED(right, (destructor)PyObject_Free);
                _Py_DECREF_SPECIALIZED(left, (destructor)PyObject_Free);
                if (res == NULL) goto pop_2_error_tier_two;
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, (PyObject *)res, 2 , ___left, ___right);
            }
            else {
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, NULL, 2 , ___left, ___right);
            }
            if (__sym_temp == NULL) goto error;
            sym_set_type(__sym_temp, PYINT_TYPE, (uint32_t)0);
            PEEK(-(-1)) = __sym_temp;
            break;
        }

        case _GUARD_BOTH_FLOAT: {
            _Py_UOpsSymbolicExpression *___left;
            _Py_UOpsSymbolicExpression *___right;
            ___right = stack_pointer[-1];
            ___left = stack_pointer[-2];
            if (is_const(___left) && is_const(___right)) {
                PyObject *left = get_const(___left);
                PyObject *right = get_const(___right);
                DEOPT_IF(!PyFloat_CheckExact(left), _GUARD_BOTH_FLOAT);
                DEOPT_IF(!PyFloat_CheckExact(right), _GUARD_BOTH_FLOAT);
                DPRINTF(2, "const eliminated guard\n");
                break;
            }
            _Py_UOpsSymbolicExpression *right = (_Py_UOpsSymbolicExpression *)stack_pointer[-1];
            _Py_UOpsSymbolicExpression *left = (_Py_UOpsSymbolicExpression *)stack_pointer[-2];
            if (should_type_propagate) {
                sym_set_type((_Py_UOpsSymbolicExpression *)left, PYFLOAT_TYPE, (uint32_t)0);;
                sym_set_type((_Py_UOpsSymbolicExpression *)right, PYFLOAT_TYPE, (uint32_t)0);;
            }
            else {
                if (sym_matches_type((_Py_UOpsSymbolicExpression *)left, PYFLOAT_TYPE, (uint32_t)0) && sym_matches_type((_Py_UOpsSymbolicExpression *)right, PYFLOAT_TYPE, (uint32_t)0)) {
                    DPRINTF(2, "type propagation eliminated guard\n");
                    break;
                }
                goto guard_required;
            }
            break;
        }

        case _BINARY_OP_MULTIPLY_FLOAT: {
            _Py_UOpsSymbolicExpression *___left;
            _Py_UOpsSymbolicExpression *___right;
            ___right = stack_pointer[-1];
            ___left = stack_pointer[-2];
            STACK_SHRINK(1);
            _Py_UOpsSymbolicExpression *__sym_temp = NULL;
            if (is_const(___left) && is_const(___right)) {
                PyObject *left = get_const(___left);
                PyObject *right = get_const(___right);
                PyObject *res;
                STAT_INC(BINARY_OP, hit);
                double dres =
                    ((PyFloatObject *)left)->ob_fval *
                    ((PyFloatObject *)right)->ob_fval;
                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, (PyObject *)res, 2 , ___left, ___right);
            }
            else {
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, NULL, 2 , ___left, ___right);
            }
            if (__sym_temp == NULL) goto error;
            sym_set_type(__sym_temp, PYFLOAT_TYPE, (uint32_t)0);
            PEEK(-(-1)) = __sym_temp;
            break;
        }

        case _BINARY_OP_ADD_FLOAT: {
            _Py_UOpsSymbolicExpression *___left;
            _Py_UOpsSymbolicExpression *___right;
            ___right = stack_pointer[-1];
            ___left = stack_pointer[-2];
            STACK_SHRINK(1);
            _Py_UOpsSymbolicExpression *__sym_temp = NULL;
            if (is_const(___left) && is_const(___right)) {
                PyObject *left = get_const(___left);
                PyObject *right = get_const(___right);
                PyObject *res;
                STAT_INC(BINARY_OP, hit);
                double dres =
                    ((PyFloatObject *)left)->ob_fval +
                    ((PyFloatObject *)right)->ob_fval;
                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, (PyObject *)res, 2 , ___left, ___right);
            }
            else {
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, NULL, 2 , ___left, ___right);
            }
            if (__sym_temp == NULL) goto error;
            sym_set_type(__sym_temp, PYFLOAT_TYPE, (uint32_t)0);
            PEEK(-(-1)) = __sym_temp;
            break;
        }

        case _BINARY_OP_SUBTRACT_FLOAT: {
            _Py_UOpsSymbolicExpression *___left;
            _Py_UOpsSymbolicExpression *___right;
            ___right = stack_pointer[-1];
            ___left = stack_pointer[-2];
            STACK_SHRINK(1);
            _Py_UOpsSymbolicExpression *__sym_temp = NULL;
            if (is_const(___left) && is_const(___right)) {
                PyObject *left = get_const(___left);
                PyObject *right = get_const(___right);
                PyObject *res;
                STAT_INC(BINARY_OP, hit);
                double dres =
                    ((PyFloatObject *)left)->ob_fval -
                    ((PyFloatObject *)right)->ob_fval;
                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, (PyObject *)res, 2 , ___left, ___right);
            }
            else {
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, NULL, 2 , ___left, ___right);
            }
            if (__sym_temp == NULL) goto error;
            sym_set_type(__sym_temp, PYFLOAT_TYPE, (uint32_t)0);
            PEEK(-(-1)) = __sym_temp;
            break;
        }

        case _GUARD_BOTH_UNICODE: {
            _Py_UOpsSymbolicExpression *___left;
            _Py_UOpsSymbolicExpression *___right;
            ___right = stack_pointer[-1];
            ___left = stack_pointer[-2];
            if (is_const(___left) && is_const(___right)) {
                PyObject *left = get_const(___left);
                PyObject *right = get_const(___right);
                DEOPT_IF(!PyUnicode_CheckExact(left), _GUARD_BOTH_UNICODE);
                DEOPT_IF(!PyUnicode_CheckExact(right), _GUARD_BOTH_UNICODE);
                DPRINTF(2, "const eliminated guard\n");
                break;
            }
            _Py_UOpsSymbolicExpression *right = (_Py_UOpsSymbolicExpression *)stack_pointer[-1];
            _Py_UOpsSymbolicExpression *left = (_Py_UOpsSymbolicExpression *)stack_pointer[-2];
            if (should_type_propagate) {
                sym_set_type((_Py_UOpsSymbolicExpression *)left, PYUNICODE_TYPE, (uint32_t)0);;
                sym_set_type((_Py_UOpsSymbolicExpression *)right, PYUNICODE_TYPE, (uint32_t)0);;
            }
            else {
                if (sym_matches_type((_Py_UOpsSymbolicExpression *)left, PYUNICODE_TYPE, (uint32_t)0) && sym_matches_type((_Py_UOpsSymbolicExpression *)right, PYUNICODE_TYPE, (uint32_t)0)) {
                    DPRINTF(2, "type propagation eliminated guard\n");
                    break;
                }
                goto guard_required;
            }
            break;
        }

        case _BINARY_OP_ADD_UNICODE: {
            _Py_UOpsSymbolicExpression *___left;
            _Py_UOpsSymbolicExpression *___right;
            ___right = stack_pointer[-1];
            ___left = stack_pointer[-2];
            STACK_SHRINK(1);
            _Py_UOpsSymbolicExpression *__sym_temp = NULL;
            if (is_const(___left) && is_const(___right)) {
                PyObject *left = get_const(___left);
                PyObject *right = get_const(___right);
                PyObject *res;
                STAT_INC(BINARY_OP, hit);
                res = PyUnicode_Concat(left, right);
                _Py_DECREF_SPECIALIZED(left, _PyUnicode_ExactDealloc);
                _Py_DECREF_SPECIALIZED(right, _PyUnicode_ExactDealloc);
                if (res == NULL) goto pop_2_error_tier_two;
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, (PyObject *)res, 2 , ___left, ___right);
            }
            else {
                __sym_temp = _Py_UOpsSymbolicExpression_New(ctx, *inst, NULL, 2 , ___left, ___right);
            }
            if (__sym_temp == NULL) goto error;
            PEEK(-(-1)) = __sym_temp;
            break;
        }

        case _BINARY_OP_INPLACE_ADD_UNICODE: {
            STACK_SHRINK(2);
            break;
        }

        case _SPECIALIZE_BINARY_SUBSCR: {
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _BINARY_SUBSCR: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case BINARY_SLICE: {
            STACK_SHRINK(2);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case STORE_SLICE: {
            STACK_SHRINK(4);
            break;
        }

        case BINARY_SUBSCR_LIST_INT: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case BINARY_SUBSCR_STR_INT: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case BINARY_SUBSCR_TUPLE_INT: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case BINARY_SUBSCR_DICT: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case BINARY_SUBSCR_GETITEM: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case LIST_APPEND: {
            STACK_SHRINK(1);
            PEEK(-(-1 - (oparg-1))) = sym_init_unknown(ctx);
            break;
        }

        case SET_ADD: {
            STACK_SHRINK(1);
            PEEK(-(-1 - (oparg-1))) = sym_init_unknown(ctx);
            break;
        }

        case _SPECIALIZE_STORE_SUBSCR: {
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _STORE_SUBSCR: {
            STACK_SHRINK(3);
            break;
        }

        case STORE_SUBSCR_LIST_INT: {
            STACK_SHRINK(3);
            break;
        }

        case STORE_SUBSCR_DICT: {
            STACK_SHRINK(3);
            break;
        }

        case DELETE_SUBSCR: {
            STACK_SHRINK(2);
            break;
        }

        case CALL_INTRINSIC_1: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_INTRINSIC_2: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case RAISE_VARARGS: {
            STACK_SHRINK(oparg);
            break;
        }

        case INTERPRETER_EXIT: {
            STACK_SHRINK(1);
            break;
        }

        case _POP_FRAME: {
            STACK_SHRINK(1);
            break;
        }

        case INSTRUMENTED_RETURN_VALUE: {
            STACK_SHRINK(1);
            break;
        }

        case INSTRUMENTED_RETURN_CONST: {
            break;
        }

        case GET_AITER: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case GET_ANEXT: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case GET_AWAITABLE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _SPECIALIZE_SEND: {
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _SEND: {
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case SEND_GEN: {
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case INSTRUMENTED_YIELD_VALUE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case YIELD_VALUE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case POP_EXCEPT: {
            STACK_SHRINK(1);
            break;
        }

        case RERAISE: {
            STACK_SHRINK(1);
            break;
        }

        case END_ASYNC_FOR: {
            STACK_SHRINK(2);
            break;
        }

        case CLEANUP_THROW: {
            STACK_SHRINK(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case LOAD_ASSERTION_ERROR: {
            STACK_GROW(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case LOAD_BUILD_CLASS: {
            STACK_GROW(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case STORE_NAME: {
            STACK_SHRINK(1);
            break;
        }

        case DELETE_NAME: {
            break;
        }

        case _SPECIALIZE_UNPACK_SEQUENCE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _UNPACK_SEQUENCE: {
            STACK_SHRINK(1);
            STACK_GROW(oparg);
            break;
        }

        case UNPACK_SEQUENCE_TWO_TUPLE: {
            STACK_SHRINK(1);
            STACK_GROW(oparg);
            break;
        }

        case UNPACK_SEQUENCE_TUPLE: {
            STACK_SHRINK(1);
            STACK_GROW(oparg);
            break;
        }

        case UNPACK_SEQUENCE_LIST: {
            STACK_SHRINK(1);
            STACK_GROW(oparg);
            break;
        }

        case UNPACK_EX: {
            STACK_GROW((oparg & 0xFF) + (oparg >> 8));
            PEEK(-(-1 - (oparg >> 8))) = sym_init_unknown(ctx);
            break;
        }

        case _SPECIALIZE_STORE_ATTR: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _STORE_ATTR: {
            STACK_SHRINK(2);
            break;
        }

        case DELETE_ATTR: {
            STACK_SHRINK(1);
            break;
        }

        case STORE_GLOBAL: {
            STACK_SHRINK(1);
            break;
        }

        case DELETE_GLOBAL: {
            break;
        }

        case LOAD_LOCALS: {
            STACK_GROW(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case LOAD_FROM_DICT_OR_GLOBALS: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case LOAD_NAME: {
            STACK_GROW(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _SPECIALIZE_LOAD_GLOBAL: {
            break;
        }

        case _LOAD_GLOBAL: {
            STACK_GROW(1);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case _GUARD_GLOBALS_VERSION: {
            goto guard_required;
            break;
        }

        case _GUARD_BUILTINS_VERSION: {
            goto guard_required;
            break;
        }

        case _LOAD_GLOBAL_MODULE: {
            STACK_GROW(1);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_GLOBAL_BUILTINS: {
            STACK_GROW(1);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case DELETE_FAST: {
            break;
        }

        case MAKE_CELL: {
            break;
        }

        case DELETE_DEREF: {
            break;
        }

        case LOAD_FROM_DICT_OR_DEREF: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case LOAD_DEREF: {
            STACK_GROW(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case STORE_DEREF: {
            STACK_SHRINK(1);
            break;
        }

        case COPY_FREE_VARS: {
            break;
        }

        case BUILD_STRING: {
            STACK_SHRINK(oparg);
            STACK_GROW(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case BUILD_TUPLE: {
            STACK_SHRINK(oparg);
            STACK_GROW(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case BUILD_LIST: {
            STACK_SHRINK(oparg);
            STACK_GROW(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case LIST_EXTEND: {
            STACK_SHRINK(1);
            PEEK(-(-1 - (oparg-1))) = sym_init_unknown(ctx);
            break;
        }

        case SET_UPDATE: {
            STACK_SHRINK(1);
            PEEK(-(-1 - (oparg-1))) = sym_init_unknown(ctx);
            break;
        }

        case BUILD_SET: {
            STACK_SHRINK(oparg);
            STACK_GROW(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case BUILD_MAP: {
            STACK_SHRINK(oparg*2);
            STACK_GROW(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case SETUP_ANNOTATIONS: {
            break;
        }

        case BUILD_CONST_KEY_MAP: {
            STACK_SHRINK(oparg);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case DICT_UPDATE: {
            STACK_SHRINK(1);
            PEEK(-(-1 - (oparg - 1))) = sym_init_unknown(ctx);
            break;
        }

        case DICT_MERGE: {
            STACK_SHRINK(1);
            PEEK(-(-4 - (oparg - 1))) = sym_init_unknown(ctx);
            PEEK(-(-3 - (oparg - 1))) = sym_init_unknown(ctx);
            PEEK(-(-2 - (oparg - 1))) = sym_init_unknown(ctx);
            PEEK(-(-1 - (oparg - 1))) = sym_init_unknown(ctx);
            break;
        }

        case MAP_ADD: {
            STACK_SHRINK(2);
            PEEK(-(-1 - (oparg - 1))) = sym_init_unknown(ctx);
            break;
        }

        case INSTRUMENTED_LOAD_SUPER_ATTR: {
            STACK_SHRINK(2);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case _SPECIALIZE_LOAD_SUPER_ATTR: {
            PEEK(-(-3)) = sym_init_unknown(ctx);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_SUPER_ATTR: {
            STACK_SHRINK(2);
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case LOAD_SUPER_ATTR_ATTR: {
            STACK_SHRINK(2);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            PEEK(-(0)) = sym_init_unknown(ctx);
            break;
        }

        case LOAD_SUPER_ATTR_METHOD: {
            STACK_SHRINK(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _SPECIALIZE_LOAD_ATTR: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_ATTR: {
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case _GUARD_TYPE_VERSION: {
            _Py_UOpsSymbolicExpression *___owner;
            ___owner = stack_pointer[-1];
            if (is_const(___owner)) {
                PyObject *owner = get_const(___owner);
                uint32_t type_version = (uint32_t)CURRENT_OPERAND();
                PyTypeObject *tp = Py_TYPE(owner);
                assert(type_version != 0);
                DEOPT_IF(tp->tp_version_tag != type_version, _GUARD_TYPE_VERSION);
                DPRINTF(2, "const eliminated guard\n");
                break;
            }
            uint32_t type_version = (uint32_t)CURRENT_OPERAND();
            _Py_UOpsSymbolicExpression *owner = (_Py_UOpsSymbolicExpression *)stack_pointer[-1];
            if (should_type_propagate) {
                sym_set_type((_Py_UOpsSymbolicExpression *)owner, GUARD_TYPE_VERSION_TYPE, (uint32_t)type_version);;
            }
            else {
                if (sym_matches_type((_Py_UOpsSymbolicExpression *)owner, GUARD_TYPE_VERSION_TYPE, (uint32_t)type_version)) {
                    DPRINTF(2, "type propagation eliminated guard\n");
                    break;
                }
                goto guard_required;
            }
            break;
        }

        case _CHECK_MANAGED_OBJECT_HAS_VALUES: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_ATTR_INSTANCE_VALUE: {
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case _CHECK_ATTR_MODULE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_ATTR_MODULE: {
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case _CHECK_ATTR_WITH_HINT: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_ATTR_WITH_HINT: {
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_ATTR_SLOT: {
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case _CHECK_ATTR_CLASS: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_ATTR_CLASS: {
            STACK_GROW(((oparg & 1) ? 1 : 0));
            PEEK(-(-1 - (oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            PEEK(-(-(oparg & 1 ? 1 : 0))) = sym_init_unknown(ctx);
            break;
        }

        case LOAD_ATTR_PROPERTY: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            PEEK(-(0)) = sym_init_unknown(ctx);
            break;
        }

        case LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            PEEK(-(0)) = sym_init_unknown(ctx);
            break;
        }

        case _GUARD_DORV_VALUES: {
            _Py_UOpsSymbolicExpression *___owner;
            ___owner = stack_pointer[-1];
            if (is_const(___owner)) {
                PyObject *owner = get_const(___owner);
                assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_MANAGED_DICT);
                PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);
                DEOPT_IF(!_PyDictOrValues_IsValues(dorv), _GUARD_DORV_VALUES);
                DPRINTF(2, "const eliminated guard\n");
                break;
            }
            _Py_UOpsSymbolicExpression *owner = (_Py_UOpsSymbolicExpression *)stack_pointer[-1];
            if (should_type_propagate) {
                sym_set_type((_Py_UOpsSymbolicExpression *)owner, GUARD_DORV_VALUES_TYPE, (uint32_t)0);;
            }
            else {
                if (sym_matches_type((_Py_UOpsSymbolicExpression *)owner, GUARD_DORV_VALUES_TYPE, (uint32_t)0)) {
                    DPRINTF(2, "type propagation eliminated guard\n");
                    break;
                }
                goto guard_required;
            }
            break;
        }

        case _STORE_ATTR_INSTANCE_VALUE: {
            STACK_SHRINK(2);
            break;
        }

        case STORE_ATTR_WITH_HINT: {
            STACK_SHRINK(2);
            break;
        }

        case _STORE_ATTR_SLOT: {
            STACK_SHRINK(2);
            break;
        }

        case _SPECIALIZE_COMPARE_OP: {
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _COMPARE_OP: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case COMPARE_OP_FLOAT: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case COMPARE_OP_INT: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case COMPARE_OP_STR: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case IS_OP: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CONTAINS_OP: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CHECK_EG_MATCH: {
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CHECK_EXC_MATCH: {
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case IMPORT_NAME: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case IMPORT_FROM: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case JUMP_FORWARD: {
            break;
        }

        case JUMP_BACKWARD: {
            break;
        }

        case ENTER_EXECUTOR: {
            break;
        }

        case _POP_JUMP_IF_FALSE: {
            STACK_SHRINK(1);
            break;
        }

        case _POP_JUMP_IF_TRUE: {
            STACK_SHRINK(1);
            break;
        }

        case _IS_NONE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case JUMP_BACKWARD_NO_INTERRUPT: {
            break;
        }

        case GET_LEN: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case MATCH_CLASS: {
            STACK_SHRINK(2);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case MATCH_MAPPING: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case MATCH_SEQUENCE: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case MATCH_KEYS: {
            STACK_GROW(1);
            PEEK(-(-3)) = sym_init_unknown(ctx);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case GET_ITER: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case GET_YIELD_FROM_ITER: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _SPECIALIZE_FOR_ITER: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _FOR_ITER: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _FOR_ITER_TIER_TWO: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case INSTRUMENTED_FOR_ITER: {
            break;
        }

        case _ITER_CHECK_LIST: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _ITER_JUMP_LIST: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_LIST: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _ITER_NEXT_LIST: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _ITER_CHECK_TUPLE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _ITER_JUMP_TUPLE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_TUPLE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _ITER_NEXT_TUPLE: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _ITER_CHECK_RANGE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _ITER_JUMP_RANGE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _GUARD_NOT_EXHAUSTED_RANGE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _ITER_NEXT_RANGE: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case FOR_ITER_GEN: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case BEFORE_ASYNC_WITH: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case BEFORE_WITH: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case WITH_EXCEPT_START: {
            STACK_GROW(1);
            PEEK(-(-5)) = sym_init_unknown(ctx);
            PEEK(-(-4)) = sym_init_unknown(ctx);
            PEEK(-(-3)) = sym_init_unknown(ctx);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case PUSH_EXC_INFO: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT: {
            _Py_UOpsSymbolicExpression *___owner;
            ___owner = stack_pointer[-1];
            if (is_const(___owner)) {
                PyObject *owner = get_const(___owner);
                assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_MANAGED_DICT);
                PyDictOrValues *dorv = _PyObject_DictOrValuesPointer(owner);
                DEOPT_IF(!_PyDictOrValues_IsValues(*dorv) && !_PyObject_MakeInstanceAttributesFromDict(owner, dorv), _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT);
                DPRINTF(2, "const eliminated guard\n");
                break;
            }
            _Py_UOpsSymbolicExpression *owner = (_Py_UOpsSymbolicExpression *)stack_pointer[-1];
            if (should_type_propagate) {
                sym_set_type((_Py_UOpsSymbolicExpression *)owner, GUARD_DORV_VALUES_INST_ATTR_FROM_DICT_TYPE, (uint32_t)0);;
            }
            else {
                if (sym_matches_type((_Py_UOpsSymbolicExpression *)owner, GUARD_DORV_VALUES_INST_ATTR_FROM_DICT_TYPE, (uint32_t)0)) {
                    DPRINTF(2, "type propagation eliminated guard\n");
                    break;
                }
                goto guard_required;
            }
            break;
        }

        case _GUARD_KEYS_VERSION: {
            _Py_UOpsSymbolicExpression *___owner;
            ___owner = stack_pointer[-1];
            if (is_const(___owner)) {
                PyObject *owner = get_const(___owner);
                uint32_t keys_version = (uint32_t)CURRENT_OPERAND();
                PyTypeObject *owner_cls = Py_TYPE(owner);
                PyHeapTypeObject *owner_heap_type = (PyHeapTypeObject *)owner_cls;
                DEOPT_IF(owner_heap_type->ht_cached_keys->dk_version != keys_version, _GUARD_KEYS_VERSION);
                DPRINTF(2, "const eliminated guard\n");
                break;
            }
            uint32_t keys_version = (uint32_t)CURRENT_OPERAND();
            _Py_UOpsSymbolicExpression *owner = (_Py_UOpsSymbolicExpression *)stack_pointer[-1];
            if (should_type_propagate) {
                sym_set_type((_Py_UOpsSymbolicExpression *)owner, GUARD_KEYS_VERSION_TYPE, (uint32_t)keys_version);;
            }
            else {
                if (sym_matches_type((_Py_UOpsSymbolicExpression *)owner, GUARD_KEYS_VERSION_TYPE, (uint32_t)keys_version)) {
                    DPRINTF(2, "type propagation eliminated guard\n");
                    break;
                }
                goto guard_required;
            }
            break;
        }

        case _LOAD_ATTR_METHOD_WITH_VALUES: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_ATTR_METHOD_NO_DICT: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_WITH_VALUES: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            PEEK(-(0)) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_NO_DICT: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            PEEK(-(0)) = sym_init_unknown(ctx);
            break;
        }

        case _CHECK_ATTR_METHOD_LAZY_DICT: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _LOAD_ATTR_METHOD_LAZY_DICT: {
            STACK_GROW(1);
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case INSTRUMENTED_CALL: {
            break;
        }

        case _SPECIALIZE_CALL: {
            PEEK(-(-2 - oparg)) = sym_init_unknown(ctx);
            PEEK(-(-1 - oparg)) = sym_init_unknown(ctx);
            break;
        }

        case _CALL: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _CHECK_CALL_BOUND_METHOD_EXACT_ARGS: {
            _Py_UOpsSymbolicExpression *___callable;
            _Py_UOpsSymbolicExpression *___null;
            ___null = stack_pointer[-1 - oparg];
            ___callable = stack_pointer[-2 - oparg];
            if (is_const(___callable) && is_const(___null)) {
                PyObject *callable = get_const(___callable);
                PyObject *null = get_const(___null);
                DEOPT_IF(null != NULL, _CHECK_CALL_BOUND_METHOD_EXACT_ARGS);
                DEOPT_IF(Py_TYPE(callable) != &PyMethod_Type, _CHECK_CALL_BOUND_METHOD_EXACT_ARGS);
                DPRINTF(2, "const eliminated guard\n");
                break;
            }
            _Py_UOpsSymbolicExpression *null = (_Py_UOpsSymbolicExpression *)stack_pointer[-1 - oparg];
            _Py_UOpsSymbolicExpression *callable = (_Py_UOpsSymbolicExpression *)stack_pointer[-2 - oparg];
            if (should_type_propagate) {
                sym_set_type((_Py_UOpsSymbolicExpression *)callable, PYMETHOD_TYPE, (uint32_t)0);;
                sym_set_type((_Py_UOpsSymbolicExpression *)null, NULL_TYPE, (uint32_t)0);;
            }
            else {
                if (sym_matches_type((_Py_UOpsSymbolicExpression *)callable, PYMETHOD_TYPE, (uint32_t)0) && sym_matches_type((_Py_UOpsSymbolicExpression *)null, NULL_TYPE, (uint32_t)0)) {
                    DPRINTF(2, "type propagation eliminated guard\n");
                    break;
                }
                goto guard_required;
            }
            break;
        }

        case _INIT_CALL_BOUND_METHOD_EXACT_ARGS: {
            PEEK(-(-2 - oparg)) = sym_init_unknown(ctx);
            PEEK(-(-1 - oparg)) = sym_init_unknown(ctx);
            break;
        }

        case _CHECK_PEP_523: {
            goto guard_required;
            break;
        }

        case _CHECK_FUNCTION_EXACT_ARGS: {
            PEEK(-(-2 - oparg)) = sym_init_unknown(ctx);
            PEEK(-(-1 - oparg)) = sym_init_unknown(ctx);
            break;
        }

        case _CHECK_STACK_SPACE: {
            PEEK(-(-2 - oparg)) = sym_init_unknown(ctx);
            PEEK(-(-1 - oparg)) = sym_init_unknown(ctx);
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _PUSH_FRAME: {
            STACK_SHRINK(1);
            PEEK(-(0)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_PY_WITH_DEFAULTS: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_TYPE_1: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_STR_1: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_TUPLE_1: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_ALLOC_AND_ENTER_INIT: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case EXIT_INIT_CHECK: {
            STACK_SHRINK(1);
            break;
        }

        case CALL_BUILTIN_CLASS: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_BUILTIN_O: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_BUILTIN_FAST: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_BUILTIN_FAST_WITH_KEYWORDS: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_LEN: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_ISINSTANCE: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_LIST_APPEND: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_METHOD_DESCRIPTOR_O: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_METHOD_DESCRIPTOR_NOARGS: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CALL_METHOD_DESCRIPTOR_FAST: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case INSTRUMENTED_CALL_KW: {
            break;
        }

        case CALL_KW: {
            STACK_SHRINK(oparg);
            STACK_SHRINK(2);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case INSTRUMENTED_CALL_FUNCTION_EX: {
            break;
        }

        case CALL_FUNCTION_EX: {
            STACK_SHRINK(((oparg & 1) ? 1 : 0));
            STACK_SHRINK(2);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case MAKE_FUNCTION: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case SET_FUNCTION_ATTRIBUTE: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case RETURN_GENERATOR: {
            break;
        }

        case BUILD_SLICE: {
            STACK_SHRINK(((oparg == 3) ? 1 : 0));
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case CONVERT_VALUE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case FORMAT_SIMPLE: {
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case FORMAT_WITH_SPEC: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _SPECIALIZE_BINARY_OP: {
            PEEK(-(-2)) = sym_init_unknown(ctx);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case _BINARY_OP: {
            STACK_SHRINK(1);
            PEEK(-(-1)) = sym_init_unknown(ctx);
            break;
        }

        case INSTRUMENTED_INSTRUCTION: {
            break;
        }

        case INSTRUMENTED_JUMP_FORWARD: {
            break;
        }

        case INSTRUMENTED_JUMP_BACKWARD: {
            break;
        }

        case INSTRUMENTED_POP_JUMP_IF_TRUE: {
            break;
        }

        case INSTRUMENTED_POP_JUMP_IF_FALSE: {
            break;
        }

        case INSTRUMENTED_POP_JUMP_IF_NONE: {
            break;
        }

        case INSTRUMENTED_POP_JUMP_IF_NOT_NONE: {
            break;
        }

        case EXTENDED_ARG: {
            break;
        }

        case CACHE: {
            break;
        }

        case RESERVED: {
            break;
        }

        case _GUARD_IS_TRUE_POP: {
            STACK_SHRINK(1);
            break;
        }

        case _GUARD_IS_FALSE_POP: {
            STACK_SHRINK(1);
            break;
        }

        case _GUARD_IS_NONE_POP: {
            STACK_SHRINK(1);
            break;
        }

        case _GUARD_IS_NOT_NONE_POP: {
            STACK_SHRINK(1);
            break;
        }

        case _JUMP_TO_TOP: {
            break;
        }

        case _SET_IP: {
            break;
        }

        case _SAVE_RETURN_OFFSET: {
            break;
        }

        case _EXIT_TRACE: {
            break;
        }

        case _SHRINK_STACK: {
            STACK_SHRINK(oparg);
            break;
        }

        case _INSERT: {
            PEEK(-(-1 - oparg)) = sym_init_unknown(ctx);
            break;
        }

        case _CHECK_VALIDITY: {
            break;
        }
