// This file is generated by Tools/cases_generator/tier2_abstract_generator.py
// from:
//   Python/bytecodes.c
// Do not edit!

#ifdef TIER_ONE
    #error "This file is for Tier 2 only"
#endif
#define TIER_TWO 2

        case _NOP: {
            break;
        }

        case _RESUME_CHECK: {
            break;
        }

        /* _INSTRUMENTED_RESUME is not a viable micro-op for tier 2 */

        case _END_SEND: {
            _Py_UOpsSymbolicValue *__value_;
            _Py_UOpsSymbolicValue *__receiver_;
            __value_ = stack_pointer[-1];
            __receiver_ = stack_pointer[-2];
            __value_ = _Py_UOpsSymbolicValue_New(ctx, NULL);
            if (__value_ == NULL) { goto error; }
            stack_pointer[-2] = __value_;
            stack_pointer += -1;
            break;
        }

        case _UNARY_NEGATIVE: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _UNARY_NOT: {
            _Py_UOpsSymbolicValue *__value_;
            _Py_UOpsSymbolicValue *__res_;
            __value_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__value_)){
                PyObject *value;
                PyObject *res;
                value = get_const(__value_);
                assert(PyBool_Check(value));
                res = Py_IsFalse(value) ? Py_True : Py_False;
                __res_ = _Py_UOpsSymbolicValue_New(ctx, (PyObject *)res);
                if(__res_ == NULL) { goto error; }
                shrink_stack.oparg = 1;
                 if (emit_const(&ctx->emitter, (PyObject *)res, shrink_stack) < 0) { goto error; }
                new_inst.opcode = _NOP;}
            else {
                __res_ = _Py_UOpsSymbolicValue_New(ctx, NULL);
                if (__res_ == NULL) { goto error; }
            }
            if (__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _TO_BOOL: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _TO_BOOL_BOOL: {
            _Py_UOpsSymbolicValue *__value_;
            __value_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__value_)) {
                PyObject *value;
                value = get_const(__value_);
                if (!PyBool_Check(value)) goto error;
                STAT_INC(TO_BOOL, hit);
                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        case _TO_BOOL_INT: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _TO_BOOL_LIST: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _TO_BOOL_NONE: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _TO_BOOL_STR: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _TO_BOOL_ALWAYS_TRUE: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _UNARY_INVERT: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _GUARD_BOTH_INT: {
            _Py_UOpsSymbolicValue *__right_;
            _Py_UOpsSymbolicValue *__left_;
            __right_ = stack_pointer[-1];
            __left_ = stack_pointer[-2];
            // Constant evaluation
            if (is_const(__left_) && is_const(__right_)) {
                PyObject *right;
                PyObject *left;
                left = get_const(__left_);
                right = get_const(__right_);
                if (!PyLong_CheckExact(left)) goto error;
                if (!PyLong_CheckExact(right)) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            // Type guard elimination
            if (sym_matches_type((_Py_UOpsSymbolicValue *)__left_, PYLONG_TYPE, (uint32_t)0) && sym_matches_type((_Py_UOpsSymbolicValue *)__right_, PYLONG_TYPE, (uint32_t)0)){
                DPRINTF(2, "type propagation eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            else {
                // Type propagation
                sym_set_type((_Py_UOpsSymbolicValue *)__left_, PYLONG_TYPE, (uint32_t)0);
                sym_set_type((_Py_UOpsSymbolicValue *)__right_, PYLONG_TYPE, (uint32_t)0);
            }
            break;
        }

        case _BINARY_OP_MULTIPLY_INT: {
            _Py_UOpsSymbolicValue *__right_;
            _Py_UOpsSymbolicValue *__left_;
            _Py_UOpsSymbolicValue *__res_;
            __right_ = stack_pointer[-1];
            __left_ = stack_pointer[-2];
            // Constant evaluation
            if (is_const(__left_) && is_const(__right_)){
                PyObject *right;
                PyObject *left;
                PyObject *res;
                left = get_const(__left_);
                right = get_const(__right_);
                STAT_INC(BINARY_OP, hit);
                res = _PyLong_Multiply((PyLongObject *)left, (PyLongObject *)right);
                if (res == NULL) goto pop_2_error_tier_two;

                __res_ = _Py_UOpsSymbolicValue_New(ctx, (PyObject *)res);
                if(__res_ == NULL) { goto error; }
                shrink_stack.oparg = 2;
                 if (emit_const(&ctx->emitter, (PyObject *)res, shrink_stack) < 0) { goto error; }
                new_inst.opcode = _NOP;}
            else {
                __res_ = _Py_UOpsSymbolicValue_New(ctx, NULL);
                if (__res_ == NULL) { goto error; }
            }
            if (__res_ == NULL) goto error;
            // Type propagation
            sym_set_type(__res_, PYLONG_TYPE, (uint32_t)0);
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _BINARY_OP_ADD_INT: {
            _Py_UOpsSymbolicValue *__right_;
            _Py_UOpsSymbolicValue *__left_;
            _Py_UOpsSymbolicValue *__res_;
            __right_ = stack_pointer[-1];
            __left_ = stack_pointer[-2];
            // Constant evaluation
            if (is_const(__left_) && is_const(__right_)){
                PyObject *right;
                PyObject *left;
                PyObject *res;
                left = get_const(__left_);
                right = get_const(__right_);
                STAT_INC(BINARY_OP, hit);
                res = _PyLong_Add((PyLongObject *)left, (PyLongObject *)right);
                if (res == NULL) goto pop_2_error_tier_two;

                __res_ = _Py_UOpsSymbolicValue_New(ctx, (PyObject *)res);
                if(__res_ == NULL) { goto error; }
                shrink_stack.oparg = 2;
                 if (emit_const(&ctx->emitter, (PyObject *)res, shrink_stack) < 0) { goto error; }
                new_inst.opcode = _NOP;}
            else {
                __res_ = _Py_UOpsSymbolicValue_New(ctx, NULL);
                if (__res_ == NULL) { goto error; }
            }
            if (__res_ == NULL) goto error;
            // Type propagation
            sym_set_type(__res_, PYLONG_TYPE, (uint32_t)0);
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _BINARY_OP_SUBTRACT_INT: {
            _Py_UOpsSymbolicValue *__right_;
            _Py_UOpsSymbolicValue *__left_;
            _Py_UOpsSymbolicValue *__res_;
            __right_ = stack_pointer[-1];
            __left_ = stack_pointer[-2];
            // Constant evaluation
            if (is_const(__left_) && is_const(__right_)){
                PyObject *right;
                PyObject *left;
                PyObject *res;
                left = get_const(__left_);
                right = get_const(__right_);
                STAT_INC(BINARY_OP, hit);
                res = _PyLong_Subtract((PyLongObject *)left, (PyLongObject *)right);
                if (res == NULL) goto pop_2_error_tier_two;

                __res_ = _Py_UOpsSymbolicValue_New(ctx, (PyObject *)res);
                if(__res_ == NULL) { goto error; }
                shrink_stack.oparg = 2;
                 if (emit_const(&ctx->emitter, (PyObject *)res, shrink_stack) < 0) { goto error; }
                new_inst.opcode = _NOP;}
            else {
                __res_ = _Py_UOpsSymbolicValue_New(ctx, NULL);
                if (__res_ == NULL) { goto error; }
            }
            if (__res_ == NULL) goto error;
            // Type propagation
            sym_set_type(__res_, PYLONG_TYPE, (uint32_t)0);
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _GUARD_BOTH_FLOAT: {
            _Py_UOpsSymbolicValue *__right_;
            _Py_UOpsSymbolicValue *__left_;
            __right_ = stack_pointer[-1];
            __left_ = stack_pointer[-2];
            // Constant evaluation
            if (is_const(__left_) && is_const(__right_)) {
                PyObject *right;
                PyObject *left;
                left = get_const(__left_);
                right = get_const(__right_);
                if (!PyFloat_CheckExact(left)) goto error;
                if (!PyFloat_CheckExact(right)) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            // Type guard elimination
            if (sym_matches_type((_Py_UOpsSymbolicValue *)__left_, PYFLOAT_TYPE, (uint32_t)0) && sym_matches_type((_Py_UOpsSymbolicValue *)__right_, PYFLOAT_TYPE, (uint32_t)0)){
                DPRINTF(2, "type propagation eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            else {
                // Type propagation
                sym_set_type((_Py_UOpsSymbolicValue *)__left_, PYFLOAT_TYPE, (uint32_t)0);
                sym_set_type((_Py_UOpsSymbolicValue *)__right_, PYFLOAT_TYPE, (uint32_t)0);
            }
            break;
        }

        case _BINARY_OP_MULTIPLY_FLOAT: {
            _Py_UOpsSymbolicValue *__right_;
            _Py_UOpsSymbolicValue *__left_;
            _Py_UOpsSymbolicValue *__res_;
            __right_ = stack_pointer[-1];
            __left_ = stack_pointer[-2];
            // Constant evaluation
            if (is_const(__left_) && is_const(__right_)){
                PyObject *right;
                PyObject *left;
                PyObject *res;
                left = get_const(__left_);
                right = get_const(__right_);
                STAT_INC(BINARY_OP, hit);
                double dres =
                ((PyFloatObject *)left)->ob_fval *
                ((PyFloatObject *)right)->ob_fval;
                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
                __res_ = _Py_UOpsSymbolicValue_New(ctx, (PyObject *)res);
                if(__res_ == NULL) { goto error; }
                shrink_stack.oparg = 2;
                 if (emit_const(&ctx->emitter, (PyObject *)res, shrink_stack) < 0) { goto error; }
                new_inst.opcode = _NOP;}
            else {
                __res_ = _Py_UOpsSymbolicValue_New(ctx, NULL);
                if (__res_ == NULL) { goto error; }
            }
            if (__res_ == NULL) goto error;
            // Type propagation
            sym_set_type(__res_, PYFLOAT_TYPE, (uint32_t)0);
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _BINARY_OP_ADD_FLOAT: {
            _Py_UOpsSymbolicValue *__right_;
            _Py_UOpsSymbolicValue *__left_;
            _Py_UOpsSymbolicValue *__res_;
            __right_ = stack_pointer[-1];
            __left_ = stack_pointer[-2];
            // Constant evaluation
            if (is_const(__left_) && is_const(__right_)){
                PyObject *right;
                PyObject *left;
                PyObject *res;
                left = get_const(__left_);
                right = get_const(__right_);
                STAT_INC(BINARY_OP, hit);
                double dres =
                ((PyFloatObject *)left)->ob_fval +
                ((PyFloatObject *)right)->ob_fval;
                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
                __res_ = _Py_UOpsSymbolicValue_New(ctx, (PyObject *)res);
                if(__res_ == NULL) { goto error; }
                shrink_stack.oparg = 2;
                 if (emit_const(&ctx->emitter, (PyObject *)res, shrink_stack) < 0) { goto error; }
                new_inst.opcode = _NOP;}
            else {
                __res_ = _Py_UOpsSymbolicValue_New(ctx, NULL);
                if (__res_ == NULL) { goto error; }
            }
            if (__res_ == NULL) goto error;
            // Type propagation
            sym_set_type(__res_, PYFLOAT_TYPE, (uint32_t)0);
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _BINARY_OP_SUBTRACT_FLOAT: {
            _Py_UOpsSymbolicValue *__right_;
            _Py_UOpsSymbolicValue *__left_;
            _Py_UOpsSymbolicValue *__res_;
            __right_ = stack_pointer[-1];
            __left_ = stack_pointer[-2];
            // Constant evaluation
            if (is_const(__left_) && is_const(__right_)){
                PyObject *right;
                PyObject *left;
                PyObject *res;
                left = get_const(__left_);
                right = get_const(__right_);
                STAT_INC(BINARY_OP, hit);
                double dres =
                ((PyFloatObject *)left)->ob_fval -
                ((PyFloatObject *)right)->ob_fval;
                DECREF_INPUTS_AND_REUSE_FLOAT(left, right, dres, res);
                __res_ = _Py_UOpsSymbolicValue_New(ctx, (PyObject *)res);
                if(__res_ == NULL) { goto error; }
                shrink_stack.oparg = 2;
                 if (emit_const(&ctx->emitter, (PyObject *)res, shrink_stack) < 0) { goto error; }
                new_inst.opcode = _NOP;}
            else {
                __res_ = _Py_UOpsSymbolicValue_New(ctx, NULL);
                if (__res_ == NULL) { goto error; }
            }
            if (__res_ == NULL) goto error;
            // Type propagation
            sym_set_type(__res_, PYFLOAT_TYPE, (uint32_t)0);
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _GUARD_BOTH_UNICODE: {
            _Py_UOpsSymbolicValue *__right_;
            _Py_UOpsSymbolicValue *__left_;
            __right_ = stack_pointer[-1];
            __left_ = stack_pointer[-2];
            // Constant evaluation
            if (is_const(__left_) && is_const(__right_)) {
                PyObject *right;
                PyObject *left;
                left = get_const(__left_);
                right = get_const(__right_);
                if (!PyUnicode_CheckExact(left)) goto error;
                if (!PyUnicode_CheckExact(right)) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            // Type guard elimination
            if (sym_matches_type((_Py_UOpsSymbolicValue *)__left_, PYUNICODE_TYPE, (uint32_t)0) && sym_matches_type((_Py_UOpsSymbolicValue *)__right_, PYUNICODE_TYPE, (uint32_t)0)){
                DPRINTF(2, "type propagation eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            else {
                // Type propagation
                sym_set_type((_Py_UOpsSymbolicValue *)__left_, PYUNICODE_TYPE, (uint32_t)0);
                sym_set_type((_Py_UOpsSymbolicValue *)__right_, PYUNICODE_TYPE, (uint32_t)0);
            }
            break;
        }

        case _BINARY_OP_ADD_UNICODE: {
            _Py_UOpsSymbolicValue *__right_;
            _Py_UOpsSymbolicValue *__left_;
            _Py_UOpsSymbolicValue *__res_;
            __right_ = stack_pointer[-1];
            __left_ = stack_pointer[-2];
            // Constant evaluation
            if (is_const(__left_) && is_const(__right_)){
                PyObject *right;
                PyObject *left;
                PyObject *res;
                left = get_const(__left_);
                right = get_const(__right_);
                STAT_INC(BINARY_OP, hit);
                res = PyUnicode_Concat(left, right);
                if (res == NULL) goto pop_2_error_tier_two;

                __res_ = _Py_UOpsSymbolicValue_New(ctx, (PyObject *)res);
                if(__res_ == NULL) { goto error; }
                shrink_stack.oparg = 2;
                 if (emit_const(&ctx->emitter, (PyObject *)res, shrink_stack) < 0) { goto error; }
                new_inst.opcode = _NOP;}
            else {
                __res_ = _Py_UOpsSymbolicValue_New(ctx, NULL);
                if (__res_ == NULL) { goto error; }
            }
            if (__res_ == NULL) goto error;
            // Type propagation
            sym_set_type(__res_, PYUNICODE_TYPE, (uint32_t)0);
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _BINARY_SUBSCR: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _BINARY_SLICE: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-3] = __res_;
            stack_pointer += -2;
            break;
        }

        case _STORE_SLICE: {
            stack_pointer += -4;
            break;
        }

        case _BINARY_SUBSCR_LIST_INT: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _BINARY_SUBSCR_STR_INT: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _BINARY_SUBSCR_TUPLE_INT: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _BINARY_SUBSCR_DICT: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        /* _BINARY_SUBSCR_GETITEM is not a viable micro-op for tier 2 */

        case _LIST_APPEND: {
            stack_pointer += -1;
            break;
        }

        case _SET_ADD: {
            stack_pointer += -1;
            break;
        }

        case _STORE_SUBSCR: {
            stack_pointer += -3;
            break;
        }

        case _STORE_SUBSCR_LIST_INT: {
            stack_pointer += -3;
            break;
        }

        case _STORE_SUBSCR_DICT: {
            stack_pointer += -3;
            break;
        }

        case _DELETE_SUBSCR: {
            stack_pointer += -2;
            break;
        }

        case _CALL_INTRINSIC_1: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _CALL_INTRINSIC_2: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        /* _INSTRUMENTED_RETURN_VALUE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_RETURN_CONST is not a viable micro-op for tier 2 */

        case _GET_AITER: {
            _Py_UOpsSymbolicValue *__iter_;
            __iter_ = sym_init_unknown(ctx);
            if(__iter_ == NULL) goto error;
            stack_pointer[-1] = __iter_;
            break;
        }

        case _GET_ANEXT: {
            _Py_UOpsSymbolicValue *__awaitable_;
            __awaitable_ = sym_init_unknown(ctx);
            if(__awaitable_ == NULL) goto error;
            stack_pointer[0] = __awaitable_;
            stack_pointer += 1;
            break;
        }

        case _GET_AWAITABLE: {
            _Py_UOpsSymbolicValue *__iter_;
            __iter_ = sym_init_unknown(ctx);
            if(__iter_ == NULL) goto error;
            stack_pointer[-1] = __iter_;
            break;
        }

        /* _SEND is not a viable micro-op for tier 2 */

        /* _SEND_GEN is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_YIELD_VALUE is not a viable micro-op for tier 2 */

        case _POP_EXCEPT: {
            stack_pointer += -1;
            break;
        }

        case _LOAD_ASSERTION_ERROR: {
            _Py_UOpsSymbolicValue *__value_;
            __value_ = sym_init_unknown(ctx);
            if(__value_ == NULL) goto error;
            stack_pointer[0] = __value_;
            stack_pointer += 1;
            break;
        }

        case _LOAD_BUILD_CLASS: {
            _Py_UOpsSymbolicValue *__bc_;
            __bc_ = sym_init_unknown(ctx);
            if(__bc_ == NULL) goto error;
            stack_pointer[0] = __bc_;
            stack_pointer += 1;
            break;
        }

        case _STORE_NAME: {
            stack_pointer += -1;
            break;
        }

        case _DELETE_NAME: {
            break;
        }

        case _UNPACK_SEQUENCE: {
            for (int case_gen_i = 0; case_gen_i < (oparg); case_gen_i++) {
                *(stack_pointer + case_gen_i) = sym_init_unknown(ctx);
                if(*(stack_pointer + case_gen_i) == NULL) goto error;
            }
            stack_pointer += -1 + oparg;
            break;
        }

        case _UNPACK_SEQUENCE_TWO_TUPLE: {
            for (int case_gen_i = 0; case_gen_i < (oparg); case_gen_i++) {
                *(stack_pointer + case_gen_i) = sym_init_unknown(ctx);
                if(*(stack_pointer + case_gen_i) == NULL) goto error;
            }
            stack_pointer += -1 + oparg;
            break;
        }

        case _UNPACK_SEQUENCE_TUPLE: {
            for (int case_gen_i = 0; case_gen_i < (oparg); case_gen_i++) {
                *(stack_pointer + case_gen_i) = sym_init_unknown(ctx);
                if(*(stack_pointer + case_gen_i) == NULL) goto error;
            }
            stack_pointer += -1 + oparg;
            break;
        }

        case _UNPACK_SEQUENCE_LIST: {
            for (int case_gen_i = 0; case_gen_i < (oparg); case_gen_i++) {
                *(stack_pointer + case_gen_i) = sym_init_unknown(ctx);
                if(*(stack_pointer + case_gen_i) == NULL) goto error;
            }
            stack_pointer += -1 + oparg;
            break;
        }

        case _UNPACK_EX: {
            for (int case_gen_i = 0; case_gen_i < (oparg & 0xFF); case_gen_i++) {
                *(stack_pointer + case_gen_i) = sym_init_unknown(ctx);
                if(*(stack_pointer + case_gen_i) == NULL) goto error;
            }
            for (int case_gen_i = 0; case_gen_i < (oparg >> 8); case_gen_i++) {
                *(stack_pointer + case_gen_i) = sym_init_unknown(ctx);
                if(*(stack_pointer + case_gen_i) == NULL) goto error;
            }
            stack_pointer += (oparg >> 8) + (oparg & 0xFF);
            break;
        }

        case _STORE_ATTR: {
            stack_pointer += -2;
            break;
        }

        case _DELETE_ATTR: {
            stack_pointer += -1;
            break;
        }

        case _STORE_GLOBAL: {
            stack_pointer += -1;
            break;
        }

        case _DELETE_GLOBAL: {
            break;
        }

        case _LOAD_LOCALS: {
            _Py_UOpsSymbolicValue *__locals_;
            __locals_ = sym_init_unknown(ctx);
            if(__locals_ == NULL) goto error;
            stack_pointer[0] = __locals_;
            stack_pointer += 1;
            break;
        }

        case _LOAD_FROM_DICT_OR_GLOBALS: {
            _Py_UOpsSymbolicValue *__v_;
            __v_ = sym_init_unknown(ctx);
            if(__v_ == NULL) goto error;
            stack_pointer[-1] = __v_;
            break;
        }

        case _LOAD_NAME: {
            _Py_UOpsSymbolicValue *__v_;
            __v_ = sym_init_unknown(ctx);
            if(__v_ == NULL) goto error;
            stack_pointer[0] = __v_;
            stack_pointer += 1;
            break;
        }

        case _LOAD_GLOBAL: {
            _Py_UOpsSymbolicValue *__res_;
            _Py_UOpsSymbolicValue *__null_ = NULL;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            __null_ = sym_init_unknown(ctx);
            if(__null_ == NULL) goto error;
            sym_set_type(__null_, NULL_TYPE, 0);
            stack_pointer[0] = __res_;
            if (oparg & 1) stack_pointer[1] = __null_;
            stack_pointer += 1 + (oparg & 1);
            break;
        }

        case _GUARD_GLOBALS_VERSION: {
            break;
        }

        case _GUARD_BUILTINS_VERSION: {
            break;
        }

        case _LOAD_GLOBAL_MODULE: {
            _Py_UOpsSymbolicValue *__res_;
            _Py_UOpsSymbolicValue *__null_ = NULL;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            __null_ = sym_init_unknown(ctx);
            if(__null_ == NULL) goto error;
            sym_set_type(__null_, NULL_TYPE, 0);
            stack_pointer[0] = __res_;
            if (oparg & 1) stack_pointer[1] = __null_;
            stack_pointer += 1 + (oparg & 1);
            break;
        }

        case _LOAD_GLOBAL_BUILTINS: {
            _Py_UOpsSymbolicValue *__res_;
            _Py_UOpsSymbolicValue *__null_ = NULL;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            __null_ = sym_init_unknown(ctx);
            if(__null_ == NULL) goto error;
            sym_set_type(__null_, NULL_TYPE, 0);
            stack_pointer[0] = __res_;
            if (oparg & 1) stack_pointer[1] = __null_;
            stack_pointer += 1 + (oparg & 1);
            break;
        }

        case _DELETE_FAST: {
            break;
        }

        case _MAKE_CELL: {
            break;
        }

        case _DELETE_DEREF: {
            break;
        }

        case _LOAD_FROM_DICT_OR_DEREF: {
            _Py_UOpsSymbolicValue *__value_;
            __value_ = sym_init_unknown(ctx);
            if(__value_ == NULL) goto error;
            stack_pointer[-1] = __value_;
            break;
        }

        case _LOAD_DEREF: {
            _Py_UOpsSymbolicValue *__value_;
            __value_ = sym_init_unknown(ctx);
            if(__value_ == NULL) goto error;
            stack_pointer[0] = __value_;
            stack_pointer += 1;
            break;
        }

        case _STORE_DEREF: {
            stack_pointer += -1;
            break;
        }

        case _COPY_FREE_VARS: {
            break;
        }

        case _BUILD_STRING: {
            _Py_UOpsSymbolicValue *__str_;
            __str_ = sym_init_unknown(ctx);
            if(__str_ == NULL) goto error;
            stack_pointer[-oparg] = __str_;
            stack_pointer += 1 - oparg;
            break;
        }

        case _BUILD_TUPLE: {
            _Py_UOpsSymbolicValue *__tup_;
            __tup_ = sym_init_unknown(ctx);
            if(__tup_ == NULL) goto error;
            stack_pointer[-oparg] = __tup_;
            stack_pointer += 1 - oparg;
            break;
        }

        case _BUILD_LIST: {
            _Py_UOpsSymbolicValue *__list_;
            __list_ = sym_init_unknown(ctx);
            if(__list_ == NULL) goto error;
            stack_pointer[-oparg] = __list_;
            stack_pointer += 1 - oparg;
            break;
        }

        case _LIST_EXTEND: {
            stack_pointer += -1;
            break;
        }

        case _SET_UPDATE: {
            stack_pointer += -1;
            break;
        }

        case _BUILD_SET: {
            _Py_UOpsSymbolicValue *__set_;
            __set_ = sym_init_unknown(ctx);
            if(__set_ == NULL) goto error;
            stack_pointer[-oparg] = __set_;
            stack_pointer += 1 - oparg;
            break;
        }

        case _BUILD_MAP: {
            _Py_UOpsSymbolicValue *__map_;
            __map_ = sym_init_unknown(ctx);
            if(__map_ == NULL) goto error;
            stack_pointer[-oparg*2] = __map_;
            stack_pointer += 1 - oparg*2;
            break;
        }

        case _SETUP_ANNOTATIONS: {
            break;
        }

        case _BUILD_CONST_KEY_MAP: {
            _Py_UOpsSymbolicValue *__map_;
            __map_ = sym_init_unknown(ctx);
            if(__map_ == NULL) goto error;
            stack_pointer[-1 - oparg] = __map_;
            stack_pointer += -oparg;
            break;
        }

        case _DICT_UPDATE: {
            stack_pointer += -1;
            break;
        }

        case _DICT_MERGE: {
            stack_pointer += -1;
            break;
        }

        case _MAP_ADD: {
            stack_pointer += -2;
            break;
        }

        /* _INSTRUMENTED_LOAD_SUPER_ATTR is not a viable micro-op for tier 2 */

        case _LOAD_SUPER_ATTR_ATTR: {
            _Py_UOpsSymbolicValue *__attr_;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            stack_pointer[-3] = __attr_;
            stack_pointer += -2 + ((0) ? 1 : 0);
            break;
        }

        case _LOAD_SUPER_ATTR_METHOD: {
            _Py_UOpsSymbolicValue *__attr_;
            _Py_UOpsSymbolicValue *__self_or_null_;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            __self_or_null_ = sym_init_unknown(ctx);
            if(__self_or_null_ == NULL) goto error;
            stack_pointer[-3] = __attr_;
            stack_pointer[-2] = __self_or_null_;
            stack_pointer += -1;
            break;
        }

        case _LOAD_ATTR: {
            _Py_UOpsSymbolicValue *__attr_;
            _Py_UOpsSymbolicValue *__self_or_null_ = NULL;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            __self_or_null_ = sym_init_unknown(ctx);
            if(__self_or_null_ == NULL) goto error;
            sym_set_type(__self_or_null_, SELF_OR_NULL, 0);
            stack_pointer[-1] = __attr_;
            if (oparg & 1) stack_pointer[0] = __self_or_null_;
            stack_pointer += (oparg & 1);
            break;
        }

        case _GUARD_TYPE_VERSION: {
            _Py_UOpsSymbolicValue *__owner_;
            __owner_ = stack_pointer[-1];
            uint32_t type_version = (uint32_t)CURRENT_OPERAND();
            // Constant evaluation
            if (is_const(__owner_)) {
                PyObject *owner;
                owner = get_const(__owner_);
                PyTypeObject *tp = Py_TYPE(owner);
                assert(type_version != 0);
                if (tp->tp_version_tag != type_version) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            // Type guard elimination
            if (sym_matches_type((_Py_UOpsSymbolicValue *)__owner_, GUARD_TYPE_VERSION_TYPE, (uint32_t)type_version)){
                DPRINTF(2, "type propagation eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            else {
                // Type propagation
                sym_set_type((_Py_UOpsSymbolicValue *)__owner_, GUARD_TYPE_VERSION_TYPE, (uint32_t)type_version);
            }
            break;
        }

        case _CHECK_MANAGED_OBJECT_HAS_VALUES: {
            break;
        }

        case _LOAD_ATTR_INSTANCE_VALUE: {
            _Py_UOpsSymbolicValue *__attr_;
            _Py_UOpsSymbolicValue *__null_ = NULL;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            __null_ = sym_init_unknown(ctx);
            if(__null_ == NULL) goto error;
            sym_set_type(__null_, NULL_TYPE, 0);
            stack_pointer[-1] = __attr_;
            if (oparg & 1) stack_pointer[0] = __null_;
            stack_pointer += (oparg & 1);
            break;
        }

        case _CHECK_ATTR_MODULE: {
            _Py_UOpsSymbolicValue *__owner_;
            __owner_ = stack_pointer[-1];
            uint32_t type_version = (uint32_t)CURRENT_OPERAND();
            // Constant evaluation
            if (is_const(__owner_)) {
                PyObject *owner;
                owner = get_const(__owner_);
                if (!PyModule_CheckExact(owner)) goto error;
                PyDictObject *dict = (PyDictObject *)((PyModuleObject *)owner)->md_dict;
                assert(dict != NULL);
                if (dict->ma_keys->dk_version != type_version) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        case _LOAD_ATTR_MODULE: {
            _Py_UOpsSymbolicValue *__attr_;
            _Py_UOpsSymbolicValue *__null_ = NULL;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            __null_ = sym_init_unknown(ctx);
            if(__null_ == NULL) goto error;
            sym_set_type(__null_, NULL_TYPE, 0);
            stack_pointer[-1] = __attr_;
            if (oparg & 1) stack_pointer[0] = __null_;
            stack_pointer += (oparg & 1);
            break;
        }

        case _CHECK_ATTR_WITH_HINT: {
            _Py_UOpsSymbolicValue *__owner_;
            __owner_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__owner_)) {
                PyObject *owner;
                owner = get_const(__owner_);
                assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_MANAGED_DICT);
                PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);
                if (_PyDictOrValues_IsValues(dorv)) goto error;
                PyDictObject *dict = (PyDictObject *)_PyDictOrValues_GetDict(dorv);
                if (dict == NULL) goto error;
                assert(PyDict_CheckExact((PyObject *)dict));
                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        case _LOAD_ATTR_WITH_HINT: {
            _Py_UOpsSymbolicValue *__attr_;
            _Py_UOpsSymbolicValue *__null_ = NULL;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            __null_ = sym_init_unknown(ctx);
            if(__null_ == NULL) goto error;
            sym_set_type(__null_, NULL_TYPE, 0);
            stack_pointer[-1] = __attr_;
            if (oparg & 1) stack_pointer[0] = __null_;
            stack_pointer += (oparg & 1);
            break;
        }

        case _LOAD_ATTR_SLOT: {
            _Py_UOpsSymbolicValue *__attr_;
            _Py_UOpsSymbolicValue *__null_ = NULL;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            __null_ = sym_init_unknown(ctx);
            if(__null_ == NULL) goto error;
            sym_set_type(__null_, NULL_TYPE, 0);
            stack_pointer[-1] = __attr_;
            if (oparg & 1) stack_pointer[0] = __null_;
            stack_pointer += (oparg & 1);
            break;
        }

        case _CHECK_ATTR_CLASS: {
            _Py_UOpsSymbolicValue *__owner_;
            __owner_ = stack_pointer[-1];
            uint32_t type_version = (uint32_t)CURRENT_OPERAND();
            // Constant evaluation
            if (is_const(__owner_)) {
                PyObject *owner;
                owner = get_const(__owner_);
                if (!PyType_Check(owner)) goto error;
                assert(type_version != 0);
                if (((PyTypeObject *)owner)->tp_version_tag != type_version) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        case _LOAD_ATTR_CLASS: {
            _Py_UOpsSymbolicValue *__attr_;
            _Py_UOpsSymbolicValue *__null_ = NULL;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            __null_ = sym_init_unknown(ctx);
            if(__null_ == NULL) goto error;
            sym_set_type(__null_, NULL_TYPE, 0);
            stack_pointer[-1] = __attr_;
            if (oparg & 1) stack_pointer[0] = __null_;
            stack_pointer += (oparg & 1);
            break;
        }

        /* _LOAD_ATTR_PROPERTY is not a viable micro-op for tier 2 */

        /* _LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN is not a viable micro-op for tier 2 */

        case _GUARD_DORV_VALUES: {
            _Py_UOpsSymbolicValue *__owner_;
            __owner_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__owner_)) {
                PyObject *owner;
                owner = get_const(__owner_);
                assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_MANAGED_DICT);
                PyDictOrValues dorv = *_PyObject_DictOrValuesPointer(owner);
                if (!_PyDictOrValues_IsValues(dorv)) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            // Type guard elimination
            if (sym_matches_type((_Py_UOpsSymbolicValue *)__owner_, GUARD_DORV_VALUES_TYPE, (uint32_t)0)){
                DPRINTF(2, "type propagation eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            else {
                // Type propagation
                sym_set_type((_Py_UOpsSymbolicValue *)__owner_, GUARD_DORV_VALUES_TYPE, (uint32_t)0);
            }
            break;
        }

        case _STORE_ATTR_INSTANCE_VALUE: {
            stack_pointer += -2;
            break;
        }

        /* _STORE_ATTR_WITH_HINT is not a viable micro-op for tier 2 */

        case _STORE_ATTR_SLOT: {
            stack_pointer += -2;
            break;
        }

        case _COMPARE_OP: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _COMPARE_OP_FLOAT: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _COMPARE_OP_INT: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _COMPARE_OP_STR: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _IS_OP: {
            _Py_UOpsSymbolicValue *__b_;
            __b_ = sym_init_unknown(ctx);
            if(__b_ == NULL) goto error;
            stack_pointer[-2] = __b_;
            stack_pointer += -1;
            break;
        }

        case _CONTAINS_OP: {
            _Py_UOpsSymbolicValue *__b_;
            __b_ = sym_init_unknown(ctx);
            if(__b_ == NULL) goto error;
            stack_pointer[-2] = __b_;
            stack_pointer += -1;
            break;
        }

        case _CHECK_EG_MATCH: {
            _Py_UOpsSymbolicValue *__rest_;
            _Py_UOpsSymbolicValue *__match_;
            __rest_ = sym_init_unknown(ctx);
            if(__rest_ == NULL) goto error;
            __match_ = sym_init_unknown(ctx);
            if(__match_ == NULL) goto error;
            stack_pointer[-2] = __rest_;
            stack_pointer[-1] = __match_;
            break;
        }

        case _CHECK_EXC_MATCH: {
            _Py_UOpsSymbolicValue *__b_;
            __b_ = sym_init_unknown(ctx);
            if(__b_ == NULL) goto error;
            stack_pointer[-1] = __b_;
            break;
        }

        /* _JUMP_BACKWARD is not a viable micro-op for tier 2 */

        /* _POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 */

        /* _POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 */

        case _IS_NONE: {
            _Py_UOpsSymbolicValue *__b_;
            __b_ = sym_init_unknown(ctx);
            if(__b_ == NULL) goto error;
            stack_pointer[-1] = __b_;
            break;
        }

        case _GET_LEN: {
            _Py_UOpsSymbolicValue *__len_o_;
            __len_o_ = sym_init_unknown(ctx);
            if(__len_o_ == NULL) goto error;
            stack_pointer[0] = __len_o_;
            stack_pointer += 1;
            break;
        }

        case _MATCH_CLASS: {
            _Py_UOpsSymbolicValue *__attrs_;
            __attrs_ = sym_init_unknown(ctx);
            if(__attrs_ == NULL) goto error;
            stack_pointer[-3] = __attrs_;
            stack_pointer += -2;
            break;
        }

        case _MATCH_MAPPING: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[0] = __res_;
            stack_pointer += 1;
            break;
        }

        case _MATCH_SEQUENCE: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[0] = __res_;
            stack_pointer += 1;
            break;
        }

        case _MATCH_KEYS: {
            _Py_UOpsSymbolicValue *__values_or_none_;
            __values_or_none_ = sym_init_unknown(ctx);
            if(__values_or_none_ == NULL) goto error;
            stack_pointer[0] = __values_or_none_;
            stack_pointer += 1;
            break;
        }

        case _GET_ITER: {
            _Py_UOpsSymbolicValue *__iter_;
            __iter_ = sym_init_unknown(ctx);
            if(__iter_ == NULL) goto error;
            stack_pointer[-1] = __iter_;
            break;
        }

        case _GET_YIELD_FROM_ITER: {
            _Py_UOpsSymbolicValue *__iter_;
            __iter_ = sym_init_unknown(ctx);
            if(__iter_ == NULL) goto error;
            stack_pointer[-1] = __iter_;
            break;
        }

        /* _FOR_ITER is not a viable micro-op for tier 2 */

        case _FOR_ITER_TIER_TWO: {
            _Py_UOpsSymbolicValue *__next_;
            __next_ = sym_init_unknown(ctx);
            if(__next_ == NULL) goto error;
            stack_pointer[0] = __next_;
            stack_pointer += 1;
            break;
        }

        /* _INSTRUMENTED_FOR_ITER is not a viable micro-op for tier 2 */

        case _ITER_CHECK_LIST: {
            _Py_UOpsSymbolicValue *__iter_;
            __iter_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__iter_)) {
                PyObject *iter;
                iter = get_const(__iter_);
                if (Py_TYPE(iter) != &PyListIter_Type) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        /* _ITER_JUMP_LIST is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_LIST: {
            _Py_UOpsSymbolicValue *__iter_;
            __iter_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__iter_)) {
                PyObject *iter;
                iter = get_const(__iter_);
                _PyListIterObject *it = (_PyListIterObject *)iter;
                assert(Py_TYPE(iter) == &PyListIter_Type);
                PyListObject *seq = it->it_seq;
                if (seq == NULL) goto error;
                if (it->it_index >= PyList_GET_SIZE(seq)) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        case _ITER_NEXT_LIST: {
            _Py_UOpsSymbolicValue *__next_;
            __next_ = sym_init_unknown(ctx);
            if(__next_ == NULL) goto error;
            stack_pointer[0] = __next_;
            stack_pointer += 1;
            break;
        }

        case _ITER_CHECK_TUPLE: {
            _Py_UOpsSymbolicValue *__iter_;
            __iter_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__iter_)) {
                PyObject *iter;
                iter = get_const(__iter_);
                if (Py_TYPE(iter) != &PyTupleIter_Type) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        /* _ITER_JUMP_TUPLE is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_TUPLE: {
            _Py_UOpsSymbolicValue *__iter_;
            __iter_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__iter_)) {
                PyObject *iter;
                iter = get_const(__iter_);
                _PyTupleIterObject *it = (_PyTupleIterObject *)iter;
                assert(Py_TYPE(iter) == &PyTupleIter_Type);
                PyTupleObject *seq = it->it_seq;
                if (seq == NULL) goto error;
                if (it->it_index >= PyTuple_GET_SIZE(seq)) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        case _ITER_NEXT_TUPLE: {
            _Py_UOpsSymbolicValue *__next_;
            __next_ = sym_init_unknown(ctx);
            if(__next_ == NULL) goto error;
            stack_pointer[0] = __next_;
            stack_pointer += 1;
            break;
        }

        case _ITER_CHECK_RANGE: {
            _Py_UOpsSymbolicValue *__iter_;
            __iter_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__iter_)) {
                PyObject *iter;
                iter = get_const(__iter_);
                _PyRangeIterObject *r = (_PyRangeIterObject *)iter;
                if (Py_TYPE(r) != &PyRangeIter_Type) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        /* _ITER_JUMP_RANGE is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_RANGE: {
            _Py_UOpsSymbolicValue *__iter_;
            __iter_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__iter_)) {
                PyObject *iter;
                iter = get_const(__iter_);
                _PyRangeIterObject *r = (_PyRangeIterObject *)iter;
                assert(Py_TYPE(r) == &PyRangeIter_Type);
                if (r->len <= 0) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        case _ITER_NEXT_RANGE: {
            _Py_UOpsSymbolicValue *__next_;
            __next_ = sym_init_unknown(ctx);
            if(__next_ == NULL) goto error;
            sym_set_type(__next_, PYLONG_TYPE, 0);
            stack_pointer[0] = __next_;
            stack_pointer += 1;
            break;
        }

        /* _FOR_ITER_GEN is not a viable micro-op for tier 2 */

        case _BEFORE_ASYNC_WITH: {
            _Py_UOpsSymbolicValue *__exit_;
            _Py_UOpsSymbolicValue *__res_;
            __exit_ = sym_init_unknown(ctx);
            if(__exit_ == NULL) goto error;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __exit_;
            stack_pointer[0] = __res_;
            stack_pointer += 1;
            break;
        }

        case _BEFORE_WITH: {
            _Py_UOpsSymbolicValue *__exit_;
            _Py_UOpsSymbolicValue *__res_;
            __exit_ = sym_init_unknown(ctx);
            if(__exit_ == NULL) goto error;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __exit_;
            stack_pointer[0] = __res_;
            stack_pointer += 1;
            break;
        }

        case _WITH_EXCEPT_START: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[0] = __res_;
            stack_pointer += 1;
            break;
        }

        case _PUSH_EXC_INFO: {
            _Py_UOpsSymbolicValue *__prev_exc_;
            _Py_UOpsSymbolicValue *__new_exc_;
            __prev_exc_ = sym_init_unknown(ctx);
            if(__prev_exc_ == NULL) goto error;
            __new_exc_ = sym_init_unknown(ctx);
            if(__new_exc_ == NULL) goto error;
            stack_pointer[-1] = __prev_exc_;
            stack_pointer[0] = __new_exc_;
            stack_pointer += 1;
            break;
        }

        case _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT: {
            _Py_UOpsSymbolicValue *__owner_;
            __owner_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__owner_)) {
                PyObject *owner;
                owner = get_const(__owner_);
                assert(Py_TYPE(owner)->tp_flags & Py_TPFLAGS_MANAGED_DICT);
                PyDictOrValues *dorv = _PyObject_DictOrValuesPointer(owner);
                if (!_PyDictOrValues_IsValues(*dorv) && !_PyObject_MakeInstanceAttributesFromDict(owner, dorv)) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            // Type guard elimination
            if (sym_matches_type((_Py_UOpsSymbolicValue *)__owner_, GUARD_DORV_VALUES_INST_ATTR_FROM_DICT_TYPE, (uint32_t)0)){
                DPRINTF(2, "type propagation eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            else {
                // Type propagation
                sym_set_type((_Py_UOpsSymbolicValue *)__owner_, GUARD_DORV_VALUES_INST_ATTR_FROM_DICT_TYPE, (uint32_t)0);
            }
            break;
        }

        case _GUARD_KEYS_VERSION: {
            _Py_UOpsSymbolicValue *__owner_;
            __owner_ = stack_pointer[-1];
            uint32_t keys_version = (uint32_t)CURRENT_OPERAND();
            // Constant evaluation
            if (is_const(__owner_)) {
                PyObject *owner;
                owner = get_const(__owner_);
                PyTypeObject *owner_cls = Py_TYPE(owner);
                PyHeapTypeObject *owner_heap_type = (PyHeapTypeObject *)owner_cls;
                if (owner_heap_type->ht_cached_keys->dk_version != keys_version) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            // Type guard elimination
            if (sym_matches_type((_Py_UOpsSymbolicValue *)__owner_, GUARD_KEYS_VERSION_TYPE, (uint32_t)keys_version)){
                DPRINTF(2, "type propagation eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            else {
                // Type propagation
                sym_set_type((_Py_UOpsSymbolicValue *)__owner_, GUARD_KEYS_VERSION_TYPE, (uint32_t)keys_version);
            }
            break;
        }

        case _LOAD_ATTR_METHOD_WITH_VALUES: {
            _Py_UOpsSymbolicValue *__attr_;
            _Py_UOpsSymbolicValue *__self_ = NULL;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            __self_ = sym_init_unknown(ctx);
            if(__self_ == NULL) goto error;
            stack_pointer[-1] = __attr_;
            if (1) stack_pointer[0] = __self_;
            stack_pointer += ((1) ? 1 : 0);
            break;
        }

        case _LOAD_ATTR_METHOD_NO_DICT: {
            _Py_UOpsSymbolicValue *__attr_;
            _Py_UOpsSymbolicValue *__self_ = NULL;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            __self_ = sym_init_unknown(ctx);
            if(__self_ == NULL) goto error;
            stack_pointer[-1] = __attr_;
            if (1) stack_pointer[0] = __self_;
            stack_pointer += ((1) ? 1 : 0);
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_WITH_VALUES: {
            _Py_UOpsSymbolicValue *__attr_;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            stack_pointer[-1] = __attr_;
            stack_pointer += ((0) ? 1 : 0);
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_NO_DICT: {
            _Py_UOpsSymbolicValue *__attr_;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            stack_pointer[-1] = __attr_;
            stack_pointer += ((0) ? 1 : 0);
            break;
        }

        case _CHECK_ATTR_METHOD_LAZY_DICT: {
            _Py_UOpsSymbolicValue *__owner_;
            __owner_ = stack_pointer[-1];
            // Constant evaluation
            if (is_const(__owner_)) {
                PyObject *owner;
                owner = get_const(__owner_);
                Py_ssize_t dictoffset = Py_TYPE(owner)->tp_dictoffset;
                assert(dictoffset > 0);
                PyObject *dict = *(PyObject **)((char *)owner + dictoffset);
                /* This object has a __dict__, just not yet created */
                if (dict != NULL) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            break;
        }

        case _LOAD_ATTR_METHOD_LAZY_DICT: {
            _Py_UOpsSymbolicValue *__attr_;
            _Py_UOpsSymbolicValue *__self_ = NULL;
            __attr_ = sym_init_unknown(ctx);
            if(__attr_ == NULL) goto error;
            __self_ = sym_init_unknown(ctx);
            if(__self_ == NULL) goto error;
            stack_pointer[-1] = __attr_;
            if (1) stack_pointer[0] = __self_;
            stack_pointer += ((1) ? 1 : 0);
            break;
        }

        /* _INSTRUMENTED_CALL is not a viable micro-op for tier 2 */

        /* _CALL is not a viable micro-op for tier 2 */

        case _CHECK_CALL_BOUND_METHOD_EXACT_ARGS: {
            _Py_UOpsSymbolicValue *__null_;
            _Py_UOpsSymbolicValue *__callable_;
            __null_ = stack_pointer[-1 - oparg];
            __callable_ = stack_pointer[-2 - oparg];
            // Constant evaluation
            if (is_const(__callable_) && is_const(__null_)) {
                PyObject *null;
                PyObject *callable;
                callable = get_const(__callable_);
                null = get_const(__null_);
                if (null != NULL) goto error;
                if (Py_TYPE(callable) != &PyMethod_Type) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            // Type guard elimination
            if (sym_matches_type((_Py_UOpsSymbolicValue *)__callable_, PYMETHOD_TYPE, (uint32_t)0) && sym_matches_type((_Py_UOpsSymbolicValue *)__null_, NULL_TYPE, (uint32_t)0)){
                DPRINTF(2, "type propagation eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            else {
                // Type propagation
                sym_set_type((_Py_UOpsSymbolicValue *)__callable_, PYMETHOD_TYPE, (uint32_t)0);
                sym_set_type((_Py_UOpsSymbolicValue *)__null_, NULL_TYPE, (uint32_t)0);
            }
            break;
        }

        case _INIT_CALL_BOUND_METHOD_EXACT_ARGS: {
            _Py_UOpsSymbolicValue *__func_;
            _Py_UOpsSymbolicValue *__self_;
            __func_ = sym_init_unknown(ctx);
            if(__func_ == NULL) goto error;
            __self_ = sym_init_unknown(ctx);
            if(__self_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __func_;
            stack_pointer[-1 - oparg] = __self_;
            break;
        }

        case _CHECK_PEP_523: {
            break;
        }

        case _CHECK_FUNCTION_EXACT_ARGS: {
            _Py_UOpsSymbolicValue *__self_or_null_;
            _Py_UOpsSymbolicValue *__callable_;
            __self_or_null_ = stack_pointer[-1 - oparg];
            __callable_ = stack_pointer[-2 - oparg];
            uint32_t func_version = (uint32_t)CURRENT_OPERAND();
            // Constant evaluation
            if (is_const(__callable_) && is_const(__self_or_null_)) {
                PyObject *self_or_null;
                PyObject *callable;
                callable = get_const(__callable_);
                self_or_null = get_const(__self_or_null_);
                if (!PyFunction_Check(callable)) goto error;
                PyFunctionObject *func = (PyFunctionObject *)callable;
                if (func->func_version != func_version) goto error;
                PyCodeObject *code = (PyCodeObject *)func->func_code;
                if (code->co_argcount != oparg + (self_or_null != NULL)) goto error;

                DPRINTF(3, "const eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            // Type guard elimination
            if (sym_matches_type((_Py_UOpsSymbolicValue *)__callable_, PYFUNCTION_TYPE_VERSION_TYPE, (uint32_t)func_version)){
                DPRINTF(2, "type propagation eliminated guard\n");
                new_inst.opcode = _NOP;break;
            }
            else {
                // Type propagation
                sym_set_type((_Py_UOpsSymbolicValue *)__callable_, PYFUNCTION_TYPE_VERSION_TYPE, (uint32_t)func_version);
            }
            break;
        }

        case _CHECK_STACK_SPACE: {
            break;
        }

        /* _CALL_PY_WITH_DEFAULTS is not a viable micro-op for tier 2 */

        case _CALL_TYPE_1: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_STR_1: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_TUPLE_1: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        /* _CALL_ALLOC_AND_ENTER_INIT is not a viable micro-op for tier 2 */

        case _EXIT_INIT_CHECK: {
            stack_pointer += -1;
            break;
        }

        case _CALL_BUILTIN_CLASS: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_BUILTIN_O: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_BUILTIN_FAST: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_BUILTIN_FAST_WITH_KEYWORDS: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_LEN: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_ISINSTANCE: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_O: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_NOARGS: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2 - oparg] = __res_;
            stack_pointer += -1 - oparg;
            break;
        }

        /* _INSTRUMENTED_CALL_KW is not a viable micro-op for tier 2 */

        /* _CALL_KW is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_CALL_FUNCTION_EX is not a viable micro-op for tier 2 */

        /* _CALL_FUNCTION_EX is not a viable micro-op for tier 2 */

        case _MAKE_FUNCTION: {
            _Py_UOpsSymbolicValue *__func_;
            __func_ = sym_init_unknown(ctx);
            if(__func_ == NULL) goto error;
            stack_pointer[-1] = __func_;
            break;
        }

        case _SET_FUNCTION_ATTRIBUTE: {
            _Py_UOpsSymbolicValue *__func_;
            __func_ = sym_init_unknown(ctx);
            if(__func_ == NULL) goto error;
            stack_pointer[-2] = __func_;
            stack_pointer += -1;
            break;
        }

        case _BUILD_SLICE: {
            _Py_UOpsSymbolicValue *__slice_;
            __slice_ = sym_init_unknown(ctx);
            if(__slice_ == NULL) goto error;
            stack_pointer[-2 - ((oparg == 3) ? 1 : 0)] = __slice_;
            stack_pointer += -1 - ((oparg == 3) ? 1 : 0);
            break;
        }

        case _CONVERT_VALUE: {
            _Py_UOpsSymbolicValue *__result_;
            __result_ = sym_init_unknown(ctx);
            if(__result_ == NULL) goto error;
            stack_pointer[-1] = __result_;
            break;
        }

        case _FORMAT_SIMPLE: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-1] = __res_;
            break;
        }

        case _FORMAT_WITH_SPEC: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        case _BINARY_OP: {
            _Py_UOpsSymbolicValue *__res_;
            __res_ = sym_init_unknown(ctx);
            if(__res_ == NULL) goto error;
            stack_pointer[-2] = __res_;
            stack_pointer += -1;
            break;
        }

        /* _INSTRUMENTED_INSTRUCTION is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_JUMP_FORWARD is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_JUMP_BACKWARD is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_NONE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_NOT_NONE is not a viable micro-op for tier 2 */

        case _GUARD_IS_TRUE_POP: {
            stack_pointer += -1;
            break;
        }

        case _GUARD_IS_FALSE_POP: {
            stack_pointer += -1;
            break;
        }

        case _GUARD_IS_NONE_POP: {
            stack_pointer += -1;
            break;
        }

        case _GUARD_IS_NOT_NONE_POP: {
            stack_pointer += -1;
            break;
        }

        case _JUMP_TO_TOP: {
            break;
        }

        case _EXIT_TRACE: {
            break;
        }

        case _JUMP_ABSOLUTE: {
            break;
        }

        case _JUMP_ABSOLUTE_HEADER: {
            break;
        }

        case _LOAD_CONST_INLINE: {
            _Py_UOpsSymbolicValue *__value_;
            __value_ = sym_init_unknown(ctx);
            if(__value_ == NULL) goto error;
            stack_pointer[0] = __value_;
            stack_pointer += 1;
            break;
        }

        case _LOAD_CONST_INLINE_BORROW: {
            _Py_UOpsSymbolicValue *__value_;
            __value_ = sym_init_unknown(ctx);
            if(__value_ == NULL) goto error;
            stack_pointer[0] = __value_;
            stack_pointer += 1;
            break;
        }

        case _INTERNAL_INCREMENT_OPT_COUNTER: {
            stack_pointer += -1;
            break;
        }

        case _SHRINK_STACK: {
            stack_pointer += -oparg;
            break;
        }

#undef TIER_TWO
