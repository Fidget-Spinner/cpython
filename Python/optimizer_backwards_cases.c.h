// This file is generated by Tools/cases_generator/optimizer_backwards_generator.py
// from:
//   Python/optimizer_backwards_bytecodes.c
// Do not edit!

        case _NOP: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_PERIODIC: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _CHECK_PERIODIC_AT_END is not a viable micro-op for tier 2 */

        case _CHECK_PERIODIC_IF_NOT_YIELD_FROM: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _QUICKEN_RESUME is not a viable micro-op for tier 2 */

        /* _LOAD_BYTECODE is not a viable micro-op for tier 2 */

        case _RESUME_CHECK: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _MONITOR_RESUME is not a viable micro-op for tier 2 */

        case _LOAD_FAST_CHECK: {
            JitOptRef value;
            value = stack_pointer[-1];
            EMIT_OP_FROM_INST(this_instr);
            if (sym_is_null(value)) {
                ctx->done = true;
            }
            GETLOCAL(oparg) = value;
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_FAST: {
            JitOptRef value;
            value = stack_pointer[-1];
            EMIT_OP_FROM_INST(this_instr);
            GETLOCAL(oparg) = value;
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_FAST_BORROW: {
            JitOptRef value;
            value = stack_pointer[-1];
            EMIT_OP_FROM_INST(this_instr);
            GETLOCAL(oparg) = value;
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_FAST_AND_CLEAR: {
            JitOptRef value;
            value = stack_pointer[-1];
            EMIT_OP_FROM_INST(this_instr);
            GETLOCAL(oparg) = value;
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_CONST: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_SMALL_INT: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_FAST: {
            JitOptRef value;
            EMIT_OP_FROM_INST(this_instr);
            value = GETLOCAL(oparg);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = value;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_TOP: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = value;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_TOP_NOP: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = value;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_TOP_INT: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = value;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_TOP_FLOAT: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = value;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_TOP_UNICODE: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = value;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_TWO: {
            JitOptRef nos;
            JitOptRef tos;
            nos = sym_new_not_null(ctx);
            tos = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[0] = nos;
            stack_pointer[1] = tos;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _PUSH_NULL: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _END_FOR: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = value;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_ITER: {
            JitOptRef iter;
            JitOptRef index_or_null;
            iter = sym_new_not_null(ctx);
            index_or_null = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[0] = iter;
            stack_pointer[1] = index_or_null;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _END_SEND: {
            JitOptRef receiver;
            JitOptRef value;
            receiver = sym_new_not_null(ctx);
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = receiver;
            stack_pointer[0] = value;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _UNARY_NEGATIVE: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _UNARY_NOT: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _TO_BOOL: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _TO_BOOL_BOOL: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _TO_BOOL_INT: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _GUARD_NOS_LIST: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_TOS_LIST: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_TOS_SLICE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _TO_BOOL_LIST: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _TO_BOOL_NONE: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _GUARD_NOS_UNICODE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_TOS_UNICODE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _TO_BOOL_STR: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _REPLACE_WITH_TRUE: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _UNARY_INVERT: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _GUARD_NOS_INT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_TOS_INT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_NOS_OVERFLOWED: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_TOS_OVERFLOWED: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _BINARY_OP_MULTIPLY_INT: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-3] = left;
            stack_pointer[-2] = right;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_ADD_INT: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-3] = left;
            stack_pointer[-2] = right;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_SUBTRACT_INT: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-3] = left;
            stack_pointer[-2] = right;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_NOS_FLOAT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_TOS_FLOAT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _BINARY_OP_MULTIPLY_FLOAT: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-3] = left;
            stack_pointer[-2] = right;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_ADD_FLOAT: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-3] = left;
            stack_pointer[-2] = right;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_SUBTRACT_FLOAT: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-3] = left;
            stack_pointer[-2] = right;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_ADD_UNICODE: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-3] = left;
            stack_pointer[-2] = right;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_INPLACE_ADD_UNICODE: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[0] = left;
            stack_pointer[1] = right;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_BINARY_OP_EXTEND: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _BINARY_OP_EXTEND: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = left;
            stack_pointer[0] = right;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_SLICE: {
            JitOptRef container;
            JitOptRef start;
            JitOptRef stop;
            container = sym_new_not_null(ctx);
            start = sym_new_not_null(ctx);
            stop = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[-1] = container;
            stack_pointer[0] = start;
            stack_pointer[1] = stop;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_SLICE: {
            JitOptRef v;
            JitOptRef container;
            JitOptRef start;
            JitOptRef stop;
            v = sym_new_not_null(ctx);
            container = sym_new_not_null(ctx);
            start = sym_new_not_null(ctx);
            stop = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(4);
            stack_pointer[0] = v;
            stack_pointer[1] = container;
            stack_pointer[2] = start;
            stack_pointer[3] = stop;
            stack_pointer += 4;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_SUBSCR_LIST_INT: {
            JitOptRef list_st;
            JitOptRef sub_st;
            list_st = sym_new_not_null(ctx);
            sub_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-3] = list_st;
            stack_pointer[-2] = sub_st;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_SUBSCR_LIST_SLICE: {
            JitOptRef list_st;
            JitOptRef sub_st;
            list_st = sym_new_not_null(ctx);
            sub_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = list_st;
            stack_pointer[0] = sub_st;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_SUBSCR_STR_INT: {
            JitOptRef str_st;
            JitOptRef sub_st;
            str_st = sym_new_not_null(ctx);
            sub_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-3] = str_st;
            stack_pointer[-2] = sub_st;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_NOS_TUPLE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_TOS_TUPLE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _BINARY_OP_SUBSCR_TUPLE_INT: {
            JitOptRef tuple_st;
            JitOptRef sub_st;
            tuple_st = sym_new_not_null(ctx);
            sub_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = tuple_st;
            stack_pointer[0] = sub_st;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_NOS_DICT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_TOS_DICT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _BINARY_OP_SUBSCR_DICT: {
            JitOptRef dict_st;
            JitOptRef sub_st;
            dict_st = sym_new_not_null(ctx);
            sub_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = dict_st;
            stack_pointer[0] = sub_st;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_SUBSCR_CHECK_FUNC: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP_SUBSCR_INIT_CALL: {
            JitOptRef container;
            JitOptRef sub;
            JitOptRef getitem;
            container = sym_new_not_null(ctx);
            sub = sym_new_not_null(ctx);
            getitem = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[-1] = container;
            stack_pointer[0] = sub;
            stack_pointer[1] = getitem;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LIST_APPEND: {
            JitOptRef v;
            v = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = v;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _SET_ADD: {
            JitOptRef v;
            v = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = v;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_SUBSCR: {
            JitOptRef v;
            JitOptRef container;
            JitOptRef sub;
            v = sym_new_not_null(ctx);
            container = sym_new_not_null(ctx);
            sub = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(3);
            stack_pointer[0] = v;
            stack_pointer[1] = container;
            stack_pointer[2] = sub;
            stack_pointer += 3;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_SUBSCR_LIST_INT: {
            JitOptRef value;
            JitOptRef list_st;
            JitOptRef sub_st;
            value = sym_new_not_null(ctx);
            list_st = sym_new_not_null(ctx);
            sub_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-2] = value;
            stack_pointer[-1] = list_st;
            stack_pointer[0] = sub_st;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_SUBSCR_DICT: {
            JitOptRef value;
            JitOptRef dict_st;
            JitOptRef sub;
            value = sym_new_not_null(ctx);
            dict_st = sym_new_not_null(ctx);
            sub = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[-1] = value;
            stack_pointer[0] = dict_st;
            stack_pointer[1] = sub;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _DELETE_SUBSCR: {
            JitOptRef container;
            JitOptRef sub;
            container = sym_new_not_null(ctx);
            sub = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[0] = container;
            stack_pointer[1] = sub;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CALL_INTRINSIC_1: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _CALL_INTRINSIC_2: {
            JitOptRef value2_st;
            JitOptRef value1_st;
            value2_st = sym_new_not_null(ctx);
            value1_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = value2_st;
            stack_pointer[0] = value1_st;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _RETURN_VALUE: {
            JitOptRef res;
            JitOptRef retval;
            res = stack_pointer[-1];
            EMIT_OP_FROM_INST(this_instr);
            JitOptRef temp = PyJitRef_StripReferenceInfo(res);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            PyCodeObject *pushing_code = get_code_with_logging_backwards(this_instr);
            if (pushing_code == NULL) {
                ctx->done = true;
                break;
            }
            _Py_UOpsAbstractFrame *new_frame = frame_new(ctx, pushing_code, 1, NULL, 0);
            if (new_frame == NULL) {
                ctx->done = true;
                break;
            }
            ctx->frame = new_frame;
            ctx->curr_frame_depth++;
            stack_pointer = ctx->frame->stack_pointer;
            retval = temp;
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = retval;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GET_AITER: {
            JitOptRef obj;
            obj = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = obj;
            break;
        }

        case _GET_ANEXT: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GET_AWAITABLE: {
            JitOptRef iterable;
            iterable = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = iterable;
            break;
        }

        /* _SEND is not a viable micro-op for tier 2 */

        case _SEND_GEN_FRAME: {
            JitOptRef gen_frame;
            gen_frame = stack_pointer[-1];
            EMIT_OP_FROM_INST(this_instr);
            gen_frame = PyJitRef_NULL;
            ctx->done = true;
            break;
        }

        case _YIELD_VALUE: {
            JitOptRef value;
            JitOptRef retval;
            value = stack_pointer[-1];
            EMIT_OP_FROM_INST(this_instr);
            retval = value;
            ctx->done = true;
            stack_pointer[-1] = retval;
            break;
        }

        case _POP_EXCEPT: {
            JitOptRef exc_value;
            exc_value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = exc_value;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_COMMON_CONSTANT: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_BUILD_CLASS: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_NAME: {
            JitOptRef v;
            v = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = v;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _DELETE_NAME: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _UNPACK_SEQUENCE: {
            JitOptRef seq;
            seq = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 - oparg);
            stack_pointer[-oparg] = seq;
            stack_pointer += 1 - oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _UNPACK_SEQUENCE_TWO_TUPLE: {
            JitOptRef seq;
            seq = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-2] = seq;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _UNPACK_SEQUENCE_TUPLE: {
            JitOptRef seq;
            seq = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 - oparg);
            stack_pointer[-oparg] = seq;
            stack_pointer += 1 - oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _UNPACK_SEQUENCE_LIST: {
            JitOptRef seq;
            seq = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 - oparg);
            stack_pointer[-oparg] = seq;
            stack_pointer += 1 - oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _UNPACK_EX: {
            JitOptRef seq;
            seq = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-(oparg & 0xFF) - (oparg >> 8));
            stack_pointer[-1 - (oparg & 0xFF) - (oparg >> 8)] = seq;
            stack_pointer += -(oparg & 0xFF) - (oparg >> 8);
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_ATTR: {
            JitOptRef v;
            JitOptRef owner;
            v = sym_new_not_null(ctx);
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[0] = v;
            stack_pointer[1] = owner;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _DELETE_ATTR: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = owner;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_GLOBAL: {
            JitOptRef v;
            v = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = v;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _DELETE_GLOBAL: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _LOAD_LOCALS: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        /* _LOAD_FROM_DICT_OR_GLOBALS is not a viable micro-op for tier 2 */

        case _LOAD_NAME: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_GLOBAL: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _PUSH_NULL_CONDITIONAL: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-(oparg & 1));
            stack_pointer += -(oparg & 1);
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_GLOBALS_VERSION: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _LOAD_GLOBAL_MODULE: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_GLOBAL_BUILTINS: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _DELETE_FAST: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _MAKE_CELL: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _DELETE_DEREF: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _LOAD_FROM_DICT_OR_DEREF: {
            JitOptRef class_dict_st;
            class_dict_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = class_dict_st;
            break;
        }

        case _LOAD_DEREF: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_DEREF: {
            JitOptRef v;
            v = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = v;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _COPY_FREE_VARS: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _BUILD_STRING: {
            JitOptRef *pieces;
            pieces = &stack_pointer[-1];
            for (int _i = oparg; --_i >= 0;) {
                pieces[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1 + oparg);
            stack_pointer += -1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BUILD_INTERPOLATION: {
            JitOptRef value;
            JitOptRef str;
            JitOptRef *format;
            format = &stack_pointer[1];
            value = sym_new_not_null(ctx);
            str = sym_new_not_null(ctx);
            for (int _i = oparg & 1; --_i >= 0;) {
                format[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + (oparg & 1));
            stack_pointer[-1] = value;
            stack_pointer[0] = str;
            stack_pointer += 1 + (oparg & 1);
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BUILD_TEMPLATE: {
            JitOptRef strings;
            JitOptRef interpolations;
            strings = sym_new_not_null(ctx);
            interpolations = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = strings;
            stack_pointer[0] = interpolations;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BUILD_TUPLE: {
            JitOptRef *values;
            values = &stack_pointer[-1];
            for (int _i = oparg; --_i >= 0;) {
                values[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1 + oparg);
            stack_pointer += -1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BUILD_LIST: {
            JitOptRef *values;
            values = &stack_pointer[-1];
            for (int _i = oparg; --_i >= 0;) {
                values[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1 + oparg);
            stack_pointer += -1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LIST_EXTEND: {
            JitOptRef iterable_st;
            iterable_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = iterable_st;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _SET_UPDATE: {
            JitOptRef iterable;
            iterable = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = iterable;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BUILD_SET: {
            JitOptRef *values;
            values = &stack_pointer[-1];
            for (int _i = oparg; --_i >= 0;) {
                values[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1 + oparg);
            stack_pointer += -1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BUILD_MAP: {
            JitOptRef *values;
            values = &stack_pointer[-1];
            for (int _i = oparg*2; --_i >= 0;) {
                values[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1 + oparg*2);
            stack_pointer += -1 + oparg*2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _SETUP_ANNOTATIONS: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _DICT_UPDATE: {
            JitOptRef update;
            update = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = update;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _DICT_MERGE: {
            JitOptRef update;
            update = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = update;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _MAP_ADD: {
            JitOptRef key;
            JitOptRef value;
            key = sym_new_not_null(ctx);
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[0] = key;
            stack_pointer[1] = value;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_SUPER_ATTR_ATTR: {
            JitOptRef global_super_st;
            JitOptRef class_st;
            JitOptRef self_st;
            global_super_st = sym_new_not_null(ctx);
            class_st = sym_new_not_null(ctx);
            self_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[-1] = global_super_st;
            stack_pointer[0] = class_st;
            stack_pointer[1] = self_st;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_SUPER_ATTR_METHOD: {
            JitOptRef global_super_st;
            JitOptRef class_st;
            JitOptRef self_st;
            global_super_st = sym_new_not_null(ctx);
            class_st = sym_new_not_null(ctx);
            self_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-2] = global_super_st;
            stack_pointer[-1] = class_st;
            stack_pointer[0] = self_st;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_ATTR: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-(oparg&1));
            stack_pointer[-1 - (oparg&1)] = owner;
            stack_pointer += -(oparg&1);
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_TYPE_VERSION: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_TYPE_VERSION_AND_LOCK: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_MANAGED_OBJECT_HAS_VALUES: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _LOAD_ATTR_INSTANCE_VALUE: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-2] = owner;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_ATTR_MODULE: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = owner;
            break;
        }

        case _LOAD_ATTR_WITH_HINT: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = owner;
            break;
        }

        case _LOAD_ATTR_SLOT: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = owner;
            break;
        }

        case _CHECK_ATTR_CLASS: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _LOAD_ATTR_CLASS: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = owner;
            break;
        }

        case _LOAD_ATTR_PROPERTY_FRAME: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = owner;
            break;
        }

        /* _LOAD_ATTR_GETATTRIBUTE_OVERRIDDEN is not a viable micro-op for tier 2 */

        case _GUARD_DORV_NO_DICT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _STORE_ATTR_INSTANCE_VALUE: {
            JitOptRef value;
            JitOptRef owner;
            value = sym_new_not_null(ctx);
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = value;
            stack_pointer[0] = owner;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_ATTR_WITH_HINT: {
            JitOptRef value;
            JitOptRef owner;
            value = sym_new_not_null(ctx);
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = value;
            stack_pointer[0] = owner;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _STORE_ATTR_SLOT: {
            JitOptRef value;
            JitOptRef owner;
            value = sym_new_not_null(ctx);
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = value;
            stack_pointer[0] = owner;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _COMPARE_OP: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = left;
            stack_pointer[0] = right;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _COMPARE_OP_FLOAT: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = left;
            stack_pointer[0] = right;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _COMPARE_OP_INT: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-3] = left;
            stack_pointer[-2] = right;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _COMPARE_OP_STR: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = left;
            stack_pointer[0] = right;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _IS_OP: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = left;
            stack_pointer[0] = right;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CONTAINS_OP: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = left;
            stack_pointer[0] = right;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_TOS_ANY_SET: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CONTAINS_OP_SET: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = left;
            stack_pointer[0] = right;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CONTAINS_OP_DICT: {
            JitOptRef left;
            JitOptRef right;
            left = sym_new_not_null(ctx);
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = left;
            stack_pointer[0] = right;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CHECK_EG_MATCH: {
            JitOptRef exc_value_st;
            JitOptRef match_type_st;
            exc_value_st = sym_new_not_null(ctx);
            match_type_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-2] = exc_value_st;
            stack_pointer[-1] = match_type_st;
            break;
        }

        case _CHECK_EXC_MATCH: {
            JitOptRef right;
            right = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = right;
            break;
        }

        case _IMPORT_NAME: {
            JitOptRef level;
            JitOptRef fromlist;
            level = sym_new_not_null(ctx);
            fromlist = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = level;
            stack_pointer[0] = fromlist;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _IMPORT_FROM: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        /* _POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 */

        /* _POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 */

        case _IS_NONE: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        /* _JUMP_BACKWARD_NO_INTERRUPT is not a viable micro-op for tier 2 */

        case _GET_LEN: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _MATCH_CLASS: {
            JitOptRef subject;
            JitOptRef type;
            JitOptRef names;
            subject = sym_new_not_null(ctx);
            type = sym_new_not_null(ctx);
            names = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[-1] = subject;
            stack_pointer[0] = type;
            stack_pointer[1] = names;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _MATCH_MAPPING: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _MATCH_SEQUENCE: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _MATCH_KEYS: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GET_ITER: {
            JitOptRef iterable;
            iterable = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-2] = iterable;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GET_YIELD_FROM_ITER: {
            JitOptRef iterable;
            iterable = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = iterable;
            break;
        }

        /* _FOR_ITER is not a viable micro-op for tier 2 */

        case _FOR_ITER_TIER_TWO: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        /* _INSTRUMENTED_FOR_ITER is not a viable micro-op for tier 2 */

        case _ITER_CHECK_LIST: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _ITER_JUMP_LIST is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_LIST: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _ITER_NEXT_LIST is not a viable micro-op for tier 2 */

        case _ITER_NEXT_LIST_TIER_TWO: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _ITER_CHECK_TUPLE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _ITER_JUMP_TUPLE is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_TUPLE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _ITER_NEXT_TUPLE: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _ITER_CHECK_RANGE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _ITER_JUMP_RANGE is not a viable micro-op for tier 2 */

        case _GUARD_NOT_EXHAUSTED_RANGE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _ITER_NEXT_RANGE: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _FOR_ITER_GEN_FRAME: {
            JitOptRef gen_frame;
            gen_frame = stack_pointer[-1];
            EMIT_OP_FROM_INST(this_instr);
            gen_frame = PyJitRef_NULL;
            ctx->done = true;
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _INSERT_NULL: {
            JitOptRef self;
            self = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-2] = self;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_SPECIAL: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _WITH_EXCEPT_START: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _PUSH_EXC_INFO: {
            JitOptRef exc;
            exc = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-2] = exc;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_DORV_VALUES_INST_ATTR_FROM_DICT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_KEYS_VERSION: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _LOAD_ATTR_METHOD_WITH_VALUES: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-2] = owner;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_ATTR_METHOD_NO_DICT: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-2] = owner;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_WITH_VALUES: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = owner;
            break;
        }

        case _LOAD_ATTR_NONDESCRIPTOR_NO_DICT: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = owner;
            break;
        }

        case _CHECK_ATTR_METHOD_LAZY_DICT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _LOAD_ATTR_METHOD_LAZY_DICT: {
            JitOptRef owner;
            owner = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-2] = owner;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _MAYBE_EXPAND_METHOD: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _DO_CALL is not a viable micro-op for tier 2 */

        /* _MONITOR_CALL is not a viable micro-op for tier 2 */

        case _PY_FRAME_GENERAL: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CHECK_FUNCTION_VERSION: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_FUNCTION_VERSION_INLINE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_METHOD_VERSION: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _EXPAND_METHOD: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_IS_NOT_PY_CALLABLE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CALL_NON_PY_GENERAL: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CHECK_CALL_BOUND_METHOD_EXACT_ARGS: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _INIT_CALL_BOUND_METHOD_EXACT_ARGS: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_PEP_523: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_FUNCTION_EXACT_ARGS: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_STACK_SPACE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_RECURSION_REMAINING: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _INIT_CALL_PY_EXACT_ARGS: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _PUSH_FRAME: {
            JitOptRef new_frame;
            EMIT_OP_FROM_INST(this_instr);
            int returning_stacklevel = this_instr->error_target;
            PyCodeObject *returning_code = get_code_with_logging_backwards(this_instr);
            if (returning_code == NULL) {
                ctx->done = true;
                break;
            }
            if (frame_pop(ctx, returning_code, returning_stacklevel)) {
                break;
            }
            stack_pointer = ctx->frame->stack_pointer;
            new_frame = sym_new_unknown(ctx);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = new_frame;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_NOS_NULL: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_NOS_NOT_NULL: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_THIRD_NULL: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_CALLABLE_TYPE_1: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CALL_TYPE_1: {
            JitOptRef callable;
            JitOptRef null;
            JitOptRef arg;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            arg = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[-1] = callable;
            stack_pointer[0] = null;
            stack_pointer[1] = arg;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_CALLABLE_STR_1: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CALL_STR_1: {
            JitOptRef callable;
            JitOptRef null;
            JitOptRef arg;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            arg = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-2] = callable;
            stack_pointer[-1] = null;
            stack_pointer[0] = arg;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_CALLABLE_TUPLE_1: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CALL_TUPLE_1: {
            JitOptRef callable;
            JitOptRef null;
            JitOptRef arg;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            arg = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-2] = callable;
            stack_pointer[-1] = null;
            stack_pointer[0] = arg;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CHECK_AND_ALLOCATE_OBJECT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CREATE_INIT_FRAME: {
            JitOptRef init;
            JitOptRef self;
            JitOptRef *args;
            args = &stack_pointer[1];
            EMIT_OP_FROM_INST(this_instr);
            ctx->done = true;
            init = sym_new_unknown(ctx);
            self = sym_new_unknown(ctx);
            for (int x = 0; x < oparg; x++) {
                args[x] = sym_new_unknown(ctx);
            }
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = init;
            stack_pointer[0] = self;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _EXIT_INIT_CHECK: {
            JitOptRef should_be_none;
            should_be_none = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = should_be_none;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CALL_BUILTIN_CLASS: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CALL_BUILTIN_O: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[-1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1 + oparg);
            stack_pointer[-3] = callable;
            stack_pointer[-2] = self_or_null;
            stack_pointer += -1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CALL_BUILTIN_FAST: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CALL_BUILTIN_FAST_WITH_KEYWORDS: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_CALLABLE_LEN: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CALL_LEN: {
            JitOptRef callable;
            JitOptRef null;
            JitOptRef arg;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            arg = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-3] = callable;
            stack_pointer[-2] = null;
            stack_pointer[-1] = arg;
            break;
        }

        case _GUARD_CALLABLE_ISINSTANCE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CALL_ISINSTANCE: {
            JitOptRef callable;
            JitOptRef null;
            JitOptRef instance;
            JitOptRef cls;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            instance = sym_new_not_null(ctx);
            cls = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(3);
            stack_pointer[-1] = callable;
            stack_pointer[0] = null;
            stack_pointer[1] = instance;
            stack_pointer[2] = cls;
            stack_pointer += 3;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_CALLABLE_LIST_APPEND: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CALL_LIST_APPEND: {
            JitOptRef callable;
            JitOptRef self;
            JitOptRef arg;
            callable = sym_new_not_null(ctx);
            self = sym_new_not_null(ctx);
            arg = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-2] = callable;
            stack_pointer[-1] = self;
            stack_pointer[0] = arg;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_O: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST_WITH_KEYWORDS: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_NOARGS: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CALL_METHOD_DESCRIPTOR_FAST: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer += 1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        /* _MONITOR_CALL_KW is not a viable micro-op for tier 2 */

        case _MAYBE_EXPAND_METHOD_KW: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _DO_CALL_KW is not a viable micro-op for tier 2 */

        case _PY_FRAME_KW: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            JitOptRef kwnames;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            kwnames = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer[1 + oparg] = kwnames;
            stack_pointer += 2 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CHECK_FUNCTION_VERSION_KW: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_METHOD_VERSION_KW: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _EXPAND_METHOD_KW: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_IS_NOT_PY_CALLABLE_KW: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CALL_KW_NON_PY: {
            JitOptRef callable;
            JitOptRef self_or_null;
            JitOptRef *args;
            JitOptRef kwnames;
            args = &stack_pointer[1];
            callable = sym_new_not_null(ctx);
            self_or_null = sym_new_not_null(ctx);
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            kwnames = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2 + oparg);
            stack_pointer[-1] = callable;
            stack_pointer[0] = self_or_null;
            stack_pointer[1 + oparg] = kwnames;
            stack_pointer += 2 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _MAKE_CALLARGS_A_TUPLE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _DO_CALL_FUNCTION_EX is not a viable micro-op for tier 2 */

        case _MAKE_FUNCTION: {
            JitOptRef codeobj_st;
            codeobj_st = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = codeobj_st;
            break;
        }

        case _SET_FUNCTION_ATTRIBUTE: {
            JitOptRef attr_st;
            JitOptRef func_in;
            attr_st = sym_new_not_null(ctx);
            func_in = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = attr_st;
            stack_pointer[0] = func_in;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _RETURN_GENERATOR: {
            EMIT_OP_FROM_INST(this_instr);
            ctx->done = true;
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BUILD_SLICE: {
            JitOptRef *args;
            args = &stack_pointer[-1];
            for (int _i = oparg; --_i >= 0;) {
                args[_i] = sym_new_not_null(ctx);
            }
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1 + oparg);
            stack_pointer += -1 + oparg;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _CONVERT_VALUE: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _FORMAT_SIMPLE: {
            JitOptRef value;
            value = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = value;
            break;
        }

        case _FORMAT_WITH_SPEC: {
            JitOptRef value;
            JitOptRef fmt_spec;
            value = sym_new_not_null(ctx);
            fmt_spec = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = value;
            stack_pointer[0] = fmt_spec;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _COPY: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _BINARY_OP: {
            JitOptRef lhs;
            JitOptRef rhs;
            lhs = sym_new_not_null(ctx);
            rhs = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = lhs;
            stack_pointer[0] = rhs;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _SWAP: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _INSTRUMENTED_LINE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_INSTRUCTION is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_JUMP_FORWARD is not a viable micro-op for tier 2 */

        /* _MONITOR_JUMP_BACKWARD is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_NOT_TAKEN is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_TRUE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_FALSE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_NONE is not a viable micro-op for tier 2 */

        /* _INSTRUMENTED_POP_JUMP_IF_NOT_NONE is not a viable micro-op for tier 2 */

        case _GUARD_IS_TRUE_POP: {
            JitOptRef flag;
            flag = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = flag;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_IS_FALSE_POP: {
            JitOptRef flag;
            flag = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = flag;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_IS_NONE_POP: {
            JitOptRef val;
            val = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = val;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _GUARD_IS_NOT_NONE_POP: {
            JitOptRef val;
            val = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[0] = val;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _JUMP_TO_TOP: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _SET_IP: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_STACK_SPACE_OPERAND: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _SAVE_RETURN_OFFSET: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _EXIT_TRACE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _DYNAMIC_EXIT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _CHECK_VALIDITY: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _LOAD_CONST_INLINE: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_TOP_LOAD_CONST_INLINE: {
            JitOptRef pop;
            pop = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = pop;
            break;
        }

        case _LOAD_CONST_INLINE_BORROW: {
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_CALL: {
            JitOptRef callable;
            JitOptRef null;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[0] = callable;
            stack_pointer[1] = null;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_CALL_ONE: {
            JitOptRef callable;
            JitOptRef null;
            JitOptRef pop;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            pop = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(3);
            stack_pointer[0] = callable;
            stack_pointer[1] = null;
            stack_pointer[2] = pop;
            stack_pointer += 3;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_CALL_TWO: {
            JitOptRef callable;
            JitOptRef null;
            JitOptRef pop1;
            JitOptRef pop2;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            pop1 = sym_new_not_null(ctx);
            pop2 = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(4);
            stack_pointer[0] = callable;
            stack_pointer[1] = null;
            stack_pointer[2] = pop1;
            stack_pointer[3] = pop2;
            stack_pointer += 4;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_TOP_LOAD_CONST_INLINE_BORROW: {
            JitOptRef pop;
            pop = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-1] = pop;
            break;
        }

        case _POP_TWO_LOAD_CONST_INLINE_BORROW: {
            JitOptRef pop1;
            JitOptRef pop2;
            pop1 = sym_new_not_null(ctx);
            pop2 = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = pop1;
            stack_pointer[0] = pop2;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_CALL_LOAD_CONST_INLINE_BORROW: {
            JitOptRef callable;
            JitOptRef null;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(1);
            stack_pointer[-1] = callable;
            stack_pointer[0] = null;
            stack_pointer += 1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _POP_CALL_ONE_LOAD_CONST_INLINE_BORROW: {
            JitOptRef callable;
            JitOptRef null;
            JitOptRef pop;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            pop = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(2);
            stack_pointer[-1] = callable;
            stack_pointer[0] = null;
            stack_pointer[1] = pop;
            stack_pointer += 2;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _SHUFFLE_3_LOAD_CONST_INLINE_BORROW: {
            JitOptRef callable;
            JitOptRef null;
            JitOptRef arg;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            arg = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            stack_pointer[-3] = callable;
            stack_pointer[-2] = null;
            stack_pointer[-1] = arg;
            break;
        }

        case _POP_CALL_TWO_LOAD_CONST_INLINE_BORROW: {
            JitOptRef callable;
            JitOptRef null;
            JitOptRef pop1;
            JitOptRef pop2;
            callable = sym_new_not_null(ctx);
            null = sym_new_null(ctx);
            pop1 = sym_new_not_null(ctx);
            pop2 = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(3);
            stack_pointer[-1] = callable;
            stack_pointer[0] = null;
            stack_pointer[1] = pop1;
            stack_pointer[2] = pop2;
            stack_pointer += 3;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_CONST_UNDER_INLINE: {
            JitOptRef old;
            old = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-2] = old;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _LOAD_CONST_UNDER_INLINE_BORROW: {
            JitOptRef old;
            old = sym_new_not_null(ctx);
            EMIT_OP_FROM_INST(this_instr);
            CHECK_STACK_BOUNDS(-1);
            stack_pointer[-2] = old;
            stack_pointer += -1;
            ASSERT_WITHIN_STACK_BOUNDS(__FILE__, __LINE__);
            break;
        }

        case _START_EXECUTOR: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _MAKE_WARM: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _FATAL_ERROR: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _DEOPT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _HANDLE_PENDING_AND_DEOPT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _ERROR_POP_N: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _SPILL_OR_RELOAD: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _TIER2_RESUME_CHECK: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _COLD_EXIT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _COLD_DYNAMIC_EXIT: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_IP__PUSH_FRAME: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_IP_YIELD_VALUE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_IP_RETURN_VALUE: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        case _GUARD_IP_RETURN_GENERATOR: {
            EMIT_OP_FROM_INST(this_instr);
            break;
        }

        /* _TRACE_RECORD is not a viable micro-op for tier 2 */

